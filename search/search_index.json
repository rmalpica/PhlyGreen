{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"PhlyGreen","text":"<p>PhlyGreen is an open-source platform for aircraft designed, focused on novel propulsion architectures, supporting hybrid-electric, all-electric, and conventional configurations.  The code is under development at Sapienza Universita' di Roma. </p> <p>This guide explains the logic, workflow, and structure of each major subsystem in the codebase.</p> <p>This documentation includes:</p> <ul> <li>User Guide \u2013 learn how to run and customize missions and designs </li> <li>Developer Guide \u2013 understand the architecture and modify modules  </li> <li>API Reference \u2013 automatically generated from Python docstrings  </li> </ul> <p>This manual is designed to help both students and researchers understand how PhlyGreen works internally and how to extend it for new propulsion concepts.</p> <p>PhlyGreen has been created by Riccardo Malpica Galassi and Matteo Blandino (Sapienza University of Rome). The project has also benefited from contributions by Aeronautical Engineering Master\u2019s students, including Jo\u00e3o Delille and Valeria Falcone, as part of their thesis research.</p> <p>How to cite: M. Blandino, P. P. Ciottoli, M. M. Molinari, J. Liberatori, R. Malpica Galassi, Uncertainty Propagation of Optimal Hybrid-Electric Aircraft Designs in a Scenario-Based Framework, Journal of Aircraft (2025).</p> <p>This work is part of the research activity developed by the authors within the framework of the \u201cPNRR\u201d CN4 MOST (Mobilit\u00e0 sostenibile): SPOKE 1 (Air Mobility), WP5: \u201cMultidisciplinary design optimization and innovative solutions for next generation green aircraft with demonstrator\u201d.</p>"},{"location":"api/battery/","title":"Battery API Reference","text":""},{"location":"api/battery/#PhlyGreen.Systems.Battery.Battery.Battery","title":"Battery","text":"<pre><code>Battery(aircraft)\n</code></pre> <p>Battery electro-thermal model with safety checks.</p> <p>Handles: - Voltage model evaluated at cell level - SOC tracking through current integration - Max current enforcement - Pack configuration (series/parallel) - Thermal dynamics</p> Source code in <code>trunk/PhlyGreen/Systems/Battery/Battery.py</code> <pre><code>def __init__(self, aircraft):\n    self.aircraft = aircraft\n\n    self.pack_Vmax = 800\n    self._SOC_min = None\n    self._it = 0         # integral of current [Ah], used to compute SOC\n    self._i = None       # pack current [A]\n    self._T = None       # cell temperature [K]\n    self._cell_max_current = None\n    self.mdot = 0        # cooling mass flow estimate from heat loss model\n</code></pre>"},{"location":"api/battery/#PhlyGreen.Systems.Battery.Battery.Battery.E0","title":"E0  <code>property</code>","text":"<pre><code>E0\n</code></pre> <p>Voltage constant</p>"},{"location":"api/battery/#PhlyGreen.Systems.Battery.Battery.Battery.K","title":"K  <code>property</code>","text":"<pre><code>K\n</code></pre> <p>Polarization resistance (Arrhenius temperature correction)</p>"},{"location":"api/battery/#PhlyGreen.Systems.Battery.Battery.Battery.Q","title":"Q  <code>property</code>","text":"<pre><code>Q\n</code></pre> <p>Nominal capacity</p>"},{"location":"api/battery/#PhlyGreen.Systems.Battery.Battery.Battery.R","title":"R  <code>property</code>","text":"<pre><code>R\n</code></pre> <p>Internal ohmic resistance (Arrhenius temperature correction)</p>"},{"location":"api/battery/#PhlyGreen.Systems.Battery.Battery.Battery.SOC","title":"SOC  <code>property</code>","text":"<pre><code>SOC\n</code></pre> <p>Real-time State-Of-Charge computed from integrated current.</p>"},{"location":"api/battery/#PhlyGreen.Systems.Battery.Battery.Battery.SOC_min","title":"SOC_min  <code>property</code> <code>writable</code>","text":"<pre><code>SOC_min\n</code></pre> <p>Ensures SOC_min is between 0 and 1.</p>"},{"location":"api/battery/#PhlyGreen.Systems.Battery.Battery.Battery.Voc","title":"Voc  <code>property</code>","text":"<pre><code>Voc\n</code></pre> <p>Open-circuit pack voltage.</p>"},{"location":"api/battery/#PhlyGreen.Systems.Battery.Battery.Battery.Vout","title":"Vout  <code>property</code>","text":"<pre><code>Vout\n</code></pre> <p>Pack-level voltage from series connection.</p>"},{"location":"api/battery/#PhlyGreen.Systems.Battery.Battery.Battery.cell_Voc","title":"cell_Voc  <code>property</code>","text":"<pre><code>cell_Voc\n</code></pre> <p>Open-circuit voltage at the current SOC.</p>"},{"location":"api/battery/#PhlyGreen.Systems.Battery.Battery.Battery.cell_Vout","title":"cell_Vout  <code>property</code>","text":"<pre><code>cell_Vout\n</code></pre> <p>Actual instantaneous cell voltage. Should never drop below the minimum safe voltage.</p>"},{"location":"api/battery/#PhlyGreen.Systems.Battery.Battery.Battery.cell_i","title":"cell_i  <code>property</code>","text":"<pre><code>cell_i\n</code></pre> <p>Cell-level current (A). For parallel strings, each cell sees pack current divided by P.</p>"},{"location":"api/battery/#PhlyGreen.Systems.Battery.Battery.Battery.cell_it","title":"cell_it  <code>property</code>","text":"<pre><code>cell_it\n</code></pre> <p>Discharge per cell (Ah).</p>"},{"location":"api/battery/#PhlyGreen.Systems.Battery.Battery.Battery.Configure","title":"Configure","text":"<pre><code>Configure(parallel_cells)\n</code></pre> <p>Defines the parallel count (P_number) and computes pack-level properties: mass, volume, max power, nominal energy.</p>"},{"location":"api/battery/#PhlyGreen.Systems.Battery.Battery.Battery.Configure--parameters","title":"Parameters","text":"<p>parallel_cells : int     Number of cells in parallel (P_number).</p> Source code in <code>trunk/PhlyGreen/Systems/Battery/Battery.py</code> <pre><code>def Configure(self, parallel_cells):\n    \"\"\"\n    Defines the parallel count (P_number) and computes\n    pack-level properties: mass, volume, max power, nominal energy.\n\n    Parameters\n    ----------\n    parallel_cells : int\n        Number of cells in parallel (P_number).\n\n    \"\"\"\n    self.P_number = parallel_cells\n    self.cells_total = self.P_number * self.S_number\n\n    # physical characteristics of the whole pack:\n    stack_length = self.cell_radius * np.ceil(self.S_number / 2)\n    # stack_width = self.cell_radius * (2 + np.sqrt(3))\n    stack_width = self.cell_radius * 2\n    self.pack_volume = self.cell_height * stack_width * stack_length\n    self.pack_weight = self.cell_mass * self.cells_total\n    if self.pack_weight &gt; 3000000000000000:\n        raise BatteryError(\"OVERWEIGHT! SOMETHING IS VERY WRONG BECAUSE BATTERY IS NOT CONVERGING\")\n    # nominal pack values\n    self.pack_energy = self.cell_energy_nom * self.cells_total\n    self.pack_power_max = (\n        self.cell_max_current * self._voltageModel(0, self.cell_max_current) * self.cells_total\n    )\n    self.pack_charge = self.cell_capacity * self.P_number\n</code></pre>"},{"location":"api/battery/#PhlyGreen.Systems.Battery.Battery.Battery.Power_2_current","title":"Power_2_current","text":"<pre><code>Power_2_current(P)\n</code></pre> <p>Calculates the current output from the battery. The calculations are for a single     cell, as that is what the model is made for. The output is the current for the entire     battery pack however. The power is simply divided by the total number of cells, as     every cell delivers equal power regardless of the configuration of the battery. Receives:     P - power demanded from the battery Returns:     I_out - current output from the battery</p> Source code in <code>trunk/PhlyGreen/Systems/Battery/Battery.py</code> <pre><code>def Power_2_current(self, P):\n    \"\"\"Calculates the current output from the battery. The calculations are for a single\n        cell, as that is what the model is made for. The output is the current for the entire\n        battery pack however. The power is simply divided by the total number of cells, as\n        every cell delivers equal power regardless of the configuration of the battery.\n    Receives:\n        P - power demanded from the battery\n    Returns:\n        I_out - current output from the battery\n    \"\"\"\n\n    if P == 0:  # skips all the math if power is zero\n        return 0\n\n    # V = E0 - I*R - I*K*(Q/(Q-it)) - it*K*(Q/(Q-it)) + A*exp(-B * it)\n    # V = E0 - I*R - I*Qr - it*Qr + ee &lt;- with substitutions to make shorter\n    # P = V*I = E0*I - I^2*R - I^2*Qr - I*it*Qr + I*ee \n    # P = I^2 *(-R-Qr) + I *(E0+ee-it*Qr)\n    # quadratic solve: \n    # a*I^2 + b*I - P = 0\n\n    E0, R, K, Q = self.E0, self.R, self.K, self.Q\n    A, B = self.exp_amplitude, self.exp_time_ctt\n    it = self.cell_it\n    P = P / self.cells_total  # all cells deliver the same power\n\n    Qr = K * Q / (Q - it)\n    ee = A * np.exp(-B * it)\n    a = -R - Qr\n    b = E0 + ee - it * Qr\n    c = -P\n    Disc = b**2 - 4 * a * c  # quadratic formula discriminant\n\n    if Disc &lt; 0:\n        I_out = None\n        return I_out\n\n    else:\n        I_out = (-b + np.sqrt(Disc)) / (2 * a)  # just the quadratic formula\n\n    return I_out * self.P_number\n</code></pre>"},{"location":"api/battery/#PhlyGreen.Systems.Battery.Battery.Battery.SetInput","title":"SetInput","text":"<pre><code>SetInput()\n</code></pre> <p>This grabs the CellModel object from the aircraft class where a dictionary defines some inputs set by the user. Then according to the inputs it defines the battery model to use. The constants come from the cell_models.py module and are modified according to the user input.</p> Source code in <code>trunk/PhlyGreen/Systems/Battery/Battery.py</code> <pre><code>def SetInput(self):\n    \"\"\"\n    This grabs the CellModel object from the aircraft class where a\n    dictionary defines some inputs set by the user.\n    Then according to the inputs it defines the battery model to use.\n    The constants come from the cell_models.py module and are modified\n    according to the user input.\n    \"\"\"\n\n    bat_inputs = self.aircraft.CellInput\n            #\u00a0set the battery model class\n    self.BatteryClass = bat_inputs['Class']\n\n\n    if self.BatteryClass == 'II':\n        self.SOC_min = bat_inputs['Minimum SOC']\n        self.aircraft.mission.startT = bat_inputs['Initial temperature'] \n        self.aircraft.mission.T_battery_limit = bat_inputs['Max operative temperature'] \n\n    if self.BatteryClass == 'I':\n        self.Ebat = bat_inputs['SpecificEnergy']*3600\n        self.pbat = bat_inputs['SpecificPower']\n        self.SOC_min = bat_inputs['Minimum SOC'] \n        return\n\n    if self.BatteryClass != 'II':\n        raise Exception(f\"Unrecognized model class: {self.BatteryClass}\")\n\n    if bat_inputs['Model'] is None: # Fallback to a default model if none is given\n        model = 'Finger-Cell-Thermal'\n    else:\n        model = bat_inputs['Model']\n\n\n\n    # Get all the cell parameters\n    cell = Cell_Models[model]\n    self.Tref              = cell['Reference Temperature']     # in kelvin\n    self.T = self.Tref\n    self.exp_amplitude     = cell['Exp Amplitude']                  # in volts\n    self.exp_time_ctt      = cell['Exp Time constant']              # in Ah^-1 \n    self.cell_resistance   = cell['Internal Resistance']            # in ohms\n    self.R_arrhenius       = cell['Resistance Arrhenius Constant']  # dimensionless\n    self.polarization_ctt  = cell['Polarization Constant']          # in Volts over amp hour\n    self.K_arrhenius       = cell['Polarization Arrhenius Constant']# dimensionless\n    self.cell_capacity     = cell['Cell Capacity']                  # in Ah\n    self.Q_slope           = cell['Capacity Thermal Slope']         # in Ah per kelvin\n    self.voltage_ctt       = cell['Voltage Constant']               # in volts\n    self.E_slope           = cell['Voltage Thermal Slope']          # in volts per kelvin\n    self.cell_Vmax         = self.exp_amplitude + self.voltage_ctt  # in volts\n    self.cell_Vmin         = cell['Cell Voltage Min']               # in volts\n    self.cell_max_current  = cell['Cell Current Max']                  # dimensionless\n    self.cell_mass         = cell['Cell Mass']                      # in kg\n    self.cell_radius       = cell['Cell Radius']                    # in m\n    self.cell_height       = cell['Cell Height']                    # in m\n    self.Vnom              = cell['Cell Voltage Nominal']  # in volts\n    self.cell_energy_nom   = self.Vnom * self.cell_capacity\n\n    # Verify that the voltages are correctly set\n    if not (self.cell_Vmax &gt; self.cell_Vmin):\n        raise ValueError(\n            \"Fail_Condition_11\\nIllegal cell voltages: Vmax must be greater than Vmin\"\n        )\n\n    # Modify the cell according to the user specified energy and power densities\n    # Modify the capacity of the cell\n    if bat_inputs[\"SpecificEnergy\"] is not None:\n        ecell = bat_inputs[\"SpecificEnergy\"] * self.cell_mass   # cell energy in Wh\n        capcell = ecell / self.Vnom                             # cell charge in Ah\n        eratio = capcell / self.cell_capacity # ratio between model charge and new charge\n        #print(f\"old{self.cell_capacity}    new{capcell}\")\n\n        self.cell_capacity = capcell\n        self.cell_energy_nom = ecell\n        self.Q_slope *= eratio  # the slope is a fraction of the capacity, so it scales with the ratio of capacities\n        self.exp_time_ctt /= eratio  # divides by the ratio because its the INVERSE of the exponential zone charge\n\n        # Scale the specific power accordingly, unless a fixed one is requested\n        if bat_inputs[\"SpecificPower\"] is None:\n            self.polarization_ctt /= eratio\n            self.K_arrhenius /= eratio\n            self.cell_resistance /= eratio\n            self.R_arrhenius /= eratio\n            self.cell_max_current *= eratio\n\n        # implement this properly later if needed\n        # make the specific power a ratio of the specific energy\n        # to be able to pick a certain C rating\n        # if bat_inputs[\"SpecificPower\"] is None:\n        #     pcell = 4 * bat_inputs[\"SpecificEnergy\"] * self.cell_mass  # cell power in W\n        #     pcellnow = self.cell_max_current * self._voltageModel(0, self.cell_max_current)\n        #     pratio = pcell / pcellnow\n\n        #     self.polarization_ctt /= pratio\n        #     self.K_arrhenius /= pratio\n        #     self.cell_resistance /= pratio\n        #     self.R_arrhenius /= pratio\n        #     self.cell_max_current *= pratio\n\n\n    # Modify the internal resistance and current limit to adjust power\n    if bat_inputs[\"SpecificPower\"] is not None:\n        pcell = bat_inputs[\"SpecificPower\"] * self.cell_mass  # cell power in W\n        pcellnow = self.cell_max_current * self._voltageModel(0, self.cell_max_current)\n        pratio = pcell / pcellnow\n        #print(f\"Current ratio:{pratio}\")\n        #print(f\"peak power old:{pcellnow}\")\n\n        # Dividing the internal resistance by a ratio increases\n        # the maximum deliverable power by the same ratio\n        self.polarization_ctt /= pratio\n        self.K_arrhenius /= pratio\n        self.cell_resistance /= pratio\n        self.R_arrhenius /= pratio\n\n        # Note: the cell max current needs to be the last thing\n        # to be calculated because its setter verifies its\n        # validity against the cell properties\n        self.cell_max_current *= pratio\n    # print(f\"peak power new:{self.cell_max_current*self._voltageModel(0, self.cell_max_current)}\")\n\n\n    # Number of cells in series to achieve desired voltage.\n    # Higher voltage is preferred as it minimizes losses\n    # due to lower current being needed.\n    if bat_inputs[\"Pack Voltage\"] is not None:\n        self.pack_Vmax = bat_inputs[\"Pack Voltage\"]\n    else:\n        self.pack_Vmax = 740\n    self.S_number = np.floor(self.pack_Vmax / self.cell_Vmax)\n\n    self.cell_area_surface = 2*np.pi*self.cell_radius*self.cell_height\n    self.module_area_section = (2*self.cell_radius)**2-np.pi*self.cell_radius**2\n\n    self.Rith = 3.3*(self.cell_radius/0.022)**2 # probably need a citation for this one\n    self.Cth = 1000 * self.cell_mass\n</code></pre>"},{"location":"api/battery/#PhlyGreen.Systems.Battery.Battery.Battery.heatLoss","title":"heatLoss","text":"<pre><code>heatLoss(Ta, rho)\n</code></pre> <p>Simple differential equation describing a     simplified lumped element thermal model of the cells Receives:     - Ta   - temperature of the ambient cooling air     - rho  - density of the ambient air Returns:     - dTdt - battery temperature derivative     - P    - dissipated waste power per cell</p> Source code in <code>trunk/PhlyGreen/Systems/Battery/Battery.py</code> <pre><code>def heatLoss(self, Ta, rho):\n    \"\"\" Simple differential equation describing a\n        simplified lumped element thermal model of the cells\n    Receives:\n        - Ta   - temperature of the ambient cooling air\n        - rho  - density of the ambient air\n    Returns:\n        - dTdt - battery temperature derivative\n        - P    - dissipated waste power per cell\n    \"\"\"\n    Ta = max(Ta,273.15)\n    # print('T ambient: ', Ta)\n\n    V, Voc = self.cell_Vout, self.cell_Voc\n    i = self.cell_i\n    T, dEdT = self.T, self.E_slope\n    # print('Battery temperature: ', T-273.15)\n    Rith = self.Rith\n    Cth = self.Cth\n    P = (Voc - V) * i + dEdT * i * T\n    self.mdot = 0.0001*P\n    # if P&lt;0:\n    #     self.mdot = 0\n    h = max(\n        (  # taken from http://dx.doi.org/10.1016/j.jpowsour.2013.10.052\n            30* ( ((self.mdot) / (self.module_area_section * rho)) / 5) ** 0.8\n        ),\n        2)\n\n    if (self.phi &gt; 0.) &amp; (T &lt; 273.15 + self.aircraft.mission.T_battery_limit):\n        h = 0.            \n\n\n    # print(self.mdot)\n\n    if h == 0:  # avoid division by 0\n        dTdt = P / Cth\n    else:\n        Rth = 1 / (h * self.cell_area_surface) + Rith\n        dTdt = P / Cth + (Ta - T) / (Rth * Cth)\n    # print(f\"h: {h}   R:{Rth}     surface:{self.cell_area_surface}    crosssec:{self.module_area_section}\")\n    return dTdt, P\n</code></pre>"},{"location":"api/battery/#PhlyGreen.Systems.Battery.Battery.BatteryError","title":"BatteryError","text":"<pre><code>BatteryError(message, code=None)\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Custom exception to be caught when the battery violates physical or model constraints.</p> Source code in <code>trunk/PhlyGreen/Systems/Battery/Battery.py</code> <pre><code>def __init__(self, message, code=None):\n    super().__init__(message)\n    self.code = code\n</code></pre>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>This page explains how to install PhlyGreen, its dependencies, and the recommended development environment. The goal is to provide a clean, reproducible setup that works for both users and contributors.</p> <p>The recommended setup uses Conda to isolate dependencies and ensure consistent behavior across systems.</p>"},{"location":"getting-started/installation/#1-install-conda-if-not-already-installed","title":"1. Install Conda (if not already installed)","text":"<p>If you do not already have Conda or Miniconda, install one of the following:</p> <ul> <li>Miniconda: https://docs.conda.io/en/latest/miniconda.html </li> <li>Anaconda: https://www.anaconda.com/products/distribution</li> </ul> <p>Verify installation:</p> <pre><code>conda --version\n</code></pre>"},{"location":"getting-started/installation/#2-create-the-conda-environment","title":"2. Create the Conda Environment","text":"<p>PhlyGreen is tested with Python 3.12, so create a dedicated environment:</p> <pre><code>conda create -n phlygreen python=3.12\n</code></pre> <p>Activate it:</p> <pre><code>conda activate phlygreen\n</code></pre>"},{"location":"getting-started/installation/#3-clone-the-repository","title":"3. Clone the Repository","text":"<pre><code>git clone https://github.com/rmalpica/PhlyGreen.git\ncd PhlyGreen\n</code></pre> <p>Be aware that the repository is still private: you need the admin approval first.</p>"},{"location":"getting-started/installation/#4-install-python-dependencies","title":"4. Install Python Dependencies","text":"<p>Install required dependencies:</p> <pre><code>pip install -r requirements.txt\n</code></pre>"},{"location":"getting-started/installation/#5-install-phlygreen-editable-mode-recommended","title":"5. Install PhlyGreen (Editable Mode Recommended)","text":"<p>Install in development / editable mode:</p> <pre><code>cd PhlyGreen/trunk\npip install -e .\n</code></pre> <p>Why -e?</p> <ul> <li>Links the package to your local directory</li> <li>Any code change is immediately reflected</li> <li>No need to reinstall after editing or pulling updates</li> <li>Recommended for research and development</li> </ul> <p>For a standard installation instead:</p> <pre><code>cd PhlyGreen/trunk\npip install .\n</code></pre>"},{"location":"getting-started/installation/#6-verify-the-installation","title":"6. Verify the Installation","text":"<pre><code>python -c \"import PhlyGreen; print('PhlyGreen version:', PhlyGreen.__version__)\"\n</code></pre>"},{"location":"getting-started/installation/#7-update-your-local-copy-when-updates-are-available-in-the-repository","title":"7. Update your local copy when updates are available in the repository","text":"<pre><code>git pull\n</code></pre>"},{"location":"getting-started/logic/","title":"Program Logic","text":""},{"location":"getting-started/logic/#phlygreen-workflow","title":"PhlyGreen workflow","text":"<p><code>PhlyGreen</code> begins from a set of user-defined aircraft constraints, design targets, and a mission profile that the aircraft must be capable of completing. Together, these inputs define the configuration of the simulation. The objective of <code>PhlyGreen</code> is to determine the required size and mass of each major aircraft subsystem so that the vehicle can successfully fly the prescribed mission while respecting all aerodynamic, structural, propulsion, and energy constraints.</p> <p>To accomplish this, PhlyGreen is organized into a set of specialized modules\u2014Constraints, Mission, Performance, Powertrain, Aerodynamics, Structures, Weight, Battery, Well-to-Wake, and ClimateImpact\u2014each responsible for computing the properties of a specific subsystem. For any candidate aircraft design, these modules evaluate performance, energy use, or mass under the specified mission conditions.</p> <p></p>"},{"location":"getting-started/logic/#iterative-weight-convergence-loop","title":"Iterative Weight-Convergence Loop","text":"<p>A key feature of PhlyGreen is its iterative sizing process, centered on the aircraft's takeoff weight (WTO). Because component masses depend on the mission performance, and mission performance depends on the aircraft mass, the system is inherently coupled.</p> <p>PhlyGreen resolves this coupling using a root-finding loop: - Assume a trial takeoff weight (WTO). - Simulate the mission and size all components consistently with that assumed WTO. - Sum the resulting component masses to compute a new, \u201coutput\u201d WTO. - Compare input and output WTO values. - Repeat, adjusting the trial WTO until the two match within a user-defined tolerance.</p> <p>This loop is solved efficiently using Brent\u2019s method, a robust hybrid root-finding algorithm. Its numerical details lie beyond the scope of this documentation, but it ensures rapid and stable convergence for all supported aircraft configurations.</p> <p></p>"},{"location":"getting-started/logic/#role-of-mission-and-weight-modules","title":"Role of Mission and Weight Modules","text":"<p>The Mission module evaluates the aircraft\u2019s performance over the full mission profile. For each flight segment, it computes:</p> <ul> <li>Aerodynamic forces</li> <li>Propulsion power demand</li> <li>Fuel flow or electric power consumption</li> <li>Battery current, SOC, and temperature evolution</li> <li>Hybrid power split (if applicable)</li> </ul> <p>The Weight module then uses these mission results to compute:</p> <ul> <li>Fuel mass required to complete the mission</li> <li>Battery mass (energy- or power-constrained)</li> <li>Propulsion system mass</li> <li>Structural mass (Class I or Class II via FLOPS)</li> <li>Additional fixed payload or crew masses</li> </ul> <p>These quantities are aggregated into a total estimated takeoff weight, which becomes the output of the sizing loop.</p>"},{"location":"getting-started/logic/#energy-estimation-and-component-sizing","title":"Energy Estimation and Component Sizing","text":"<p>A central element of the workflow is the energy estimation, especially important for hybrid-electric aircraft. Over each flight segment, PhlyGreen integrates:</p> <ul> <li>Fuel power \u2192 fuel energy use</li> <li>Electrical power \u2192 battery energy use</li> <li>Peak power \u2192 power constraints on the electric system</li> </ul> <p>At the end of the mission, the energy totals are used to determine:</p> <ul> <li>fuel mass: \\(W_{fuel}=\\frac{E_{fuel}}{LHV}\\)</li> <li>battery mass, from \\(E_{bat}\\) and \\(P_{bat,peak}\\) depending on the battery model</li> </ul>"},{"location":"getting-started/running-your-first-mission/","title":"PhlyGreen Tutorial: sizing a parallel-hybrid aircraft","text":"<p>Import packages</p> In\u00a0[1]: Copied! <pre>import sys\nsys.path.insert(0,'../')\nimport PhlyGreen as pg\nimport numpy as np\nimport matplotlib.pyplot as plt\n</pre> import sys sys.path.insert(0,'../') import PhlyGreen as pg import numpy as np import matplotlib.pyplot as plt <p>Create instances of subsystems. Each one of those requires an Aircraft object as argument. By passing (None) as argument, we are creating empty objects (for the moment).</p> In\u00a0[2]: Copied! <pre>powertrain = pg.Systems.Powertrain.Powertrain(None)\nstructures = pg.Systems.Structures.Structures(None)\naerodynamics = pg.Systems.Aerodynamics.Aerodynamics(None)\nperformance = pg.Performance.Performance(None)\nmission = pg.Mission.Mission(None)\nweight = pg.Weight.Weight(None)\nconstraint = pg.Constraint.Constraint(None)\nwelltowake = pg.WellToWake.WellToWake(None)\nbattery = pg.Systems.Battery.Battery(None)\nclimateimpact = pg.ClimateImpact.ClimateImpact(None)\n</pre> powertrain = pg.Systems.Powertrain.Powertrain(None) structures = pg.Systems.Structures.Structures(None) aerodynamics = pg.Systems.Aerodynamics.Aerodynamics(None) performance = pg.Performance.Performance(None) mission = pg.Mission.Mission(None) weight = pg.Weight.Weight(None) constraint = pg.Constraint.Constraint(None) welltowake = pg.WellToWake.WellToWake(None) battery = pg.Systems.Battery.Battery(None) climateimpact = pg.ClimateImpact.ClimateImpact(None) <p>Create instance of Aircraft object.</p> In\u00a0[3]: Copied! <pre>myaircraft = pg.Aircraft(powertrain, structures, aerodynamics, performance, mission, weight, constraint, welltowake, battery, climateimpact)\n</pre> myaircraft = pg.Aircraft(powertrain, structures, aerodynamics, performance, mission, weight, constraint, welltowake, battery, climateimpact) <p>Create the connections with its subsystems.</p> In\u00a0[4]: Copied! <pre>powertrain.aircraft = myaircraft\nstructures.aircraft = myaircraft\naerodynamics.aircraft = myaircraft\nmission.aircraft = myaircraft\nperformance.aircraft = myaircraft\nweight.aircraft = myaircraft\nconstraint.aircraft = myaircraft\nwelltowake.aircraft = myaircraft\nbattery.aircraft = myaircraft\nclimateimpact.aircraft = myaircraft\n</pre> powertrain.aircraft = myaircraft structures.aircraft = myaircraft aerodynamics.aircraft = myaircraft mission.aircraft = myaircraft performance.aircraft = myaircraft weight.aircraft = myaircraft constraint.aircraft = myaircraft welltowake.aircraft = myaircraft battery.aircraft = myaircraft climateimpact.aircraft = myaircraft <p>Define input dictionaries</p> In\u00a0[5]: Copied! <pre>ConstraintsInput = {'DISA': 0.,\n                    'Cruise': {'Speed': 0.5, 'Speed Type':'Mach', 'Beta': 0.95, 'Altitude': 8000.},\n                    'AEO Climb': {'Speed': 210, 'Speed Type':'KCAS', 'Beta': 0.97, 'Altitude': 6000., 'ROC': 5},\n                    'OEI Climb': {'Speed': 1.2*34.5, 'Speed Type': 'TAS', 'Beta': 1., 'Altitude': 0., 'Climb Gradient': 0.021},\n                    'Take Off': {'Speed': 90, 'Speed Type': 'TAS', 'Beta': 1., 'Altitude': 100., 'kTO': 1.2, 'sTO': 950},\n                    'Landing':{'Speed': 59., 'Speed Type': 'TAS', 'Altitude': 500.},\n                    'Turn':{'Speed': 210, 'Speed Type': 'KCAS', 'Beta': 0.9, 'Altitude': 5000, 'Load Factor': 1.1},\n                    'Ceiling':{'Speed': 0.5, 'Beta': 0.8, 'Altitude': 9500, 'HT': 0.5},\n                    'Acceleration':{'Mach 1': 0.3, 'Mach 2':0.4, 'DT': 180, 'Altitude': 6000, 'Beta': 0.9}}\n</pre> ConstraintsInput = {'DISA': 0.,                     'Cruise': {'Speed': 0.5, 'Speed Type':'Mach', 'Beta': 0.95, 'Altitude': 8000.},                     'AEO Climb': {'Speed': 210, 'Speed Type':'KCAS', 'Beta': 0.97, 'Altitude': 6000., 'ROC': 5},                     'OEI Climb': {'Speed': 1.2*34.5, 'Speed Type': 'TAS', 'Beta': 1., 'Altitude': 0., 'Climb Gradient': 0.021},                     'Take Off': {'Speed': 90, 'Speed Type': 'TAS', 'Beta': 1., 'Altitude': 100., 'kTO': 1.2, 'sTO': 950},                     'Landing':{'Speed': 59., 'Speed Type': 'TAS', 'Altitude': 500.},                     'Turn':{'Speed': 210, 'Speed Type': 'KCAS', 'Beta': 0.9, 'Altitude': 5000, 'Load Factor': 1.1},                     'Ceiling':{'Speed': 0.5, 'Beta': 0.8, 'Altitude': 9500, 'HT': 0.5},                     'Acceleration':{'Mach 1': 0.3, 'Mach 2':0.4, 'DT': 180, 'Altitude': 6000, 'Beta': 0.9}} In\u00a0[\u00a0]: Copied! <pre>MissionInput = {'Range Mission': 750,  #nautical miles\n                'Range Diversion': 220,  #nautical miles\n                'Beta start': 0.97,\n                'Payload Weight': 4560,  # [kg]\n                'Crew Weight': 500}  # [kg]\n</pre> MissionInput = {'Range Mission': 750,  #nautical miles                 'Range Diversion': 220,  #nautical miles                 'Beta start': 0.97,                 'Payload Weight': 4560,  # [kg]                 'Crew Weight': 500}  # [kg] In\u00a0[7]: Copied! <pre>MissionStages = {'Takeoff': {'Supplied Power Ratio':{'phi': 0.}},\n                'Climb1': {'type': 'ConstantRateClimb', 'input': {'CB': 0.16, 'Speed': 77, 'StartAltitude': 100, 'EndAltitude': 1500}, 'Supplied Power Ratio':{'phi_start': 0, 'phi_end':0}},\n                 'Climb2': {'type': 'ConstantRateClimb', 'input': {'CB': 0.08, 'Speed': 120, 'StartAltitude': 1500, 'EndAltitude': 4500}, 'Supplied Power Ratio':{'phi_start': 0, 'phi_end':0 }},\n                 'Climb3': {'type': 'ConstantRateClimb', 'input': {'CB': 0.07, 'Speed': 125, 'StartAltitude': 4500, 'EndAltitude': 8000}, 'Supplied Power Ratio':{'phi_start': 0, 'phi_end':0 }},\n                 'Cruise': {'type': 'ConstantMachCruise', 'input':{ 'Mach': 0.4, 'Altitude': 8000}, 'Supplied Power Ratio':{'phi_start': 0, 'phi_end':0.5}},\n                 'Descent1': {'type': 'ConstantRateDescent', 'input':{'CB': -0.04, 'Speed': 90, 'StartAltitude': 8000, 'EndAltitude': 200}, 'Supplied Power Ratio':{'phi_start': 0.0, 'phi_end':0.0 }}}\n\nDiversionStages = {'Climb1': {'type': 'ConstantRateClimb', 'input': {'CB': 0.08, 'Speed': 110, 'StartAltitude': 200, 'EndAltitude': 3100}, 'Supplied Power Ratio':{'phi_start': 0.0, 'phi_end':0.0 }},\n                 'Cruise': {'type': 'ConstantMachCruise', 'input':{ 'Mach': 0.35, 'Altitude': 3100}, 'Supplied Power Ratio':{'phi_start': 0.0, 'phi_end':0.0}},\n                 'Descent1': {'type': 'ConstantRateDescent', 'input':{'CB': -0.04, 'Speed': 90, 'StartAltitude': 3100, 'EndAltitude': 200}, 'Supplied Power Ratio':{'phi_start': 0.0, 'phi_end':0.0 }}}\n</pre> MissionStages = {'Takeoff': {'Supplied Power Ratio':{'phi': 0.}},                 'Climb1': {'type': 'ConstantRateClimb', 'input': {'CB': 0.16, 'Speed': 77, 'StartAltitude': 100, 'EndAltitude': 1500}, 'Supplied Power Ratio':{'phi_start': 0, 'phi_end':0}},                  'Climb2': {'type': 'ConstantRateClimb', 'input': {'CB': 0.08, 'Speed': 120, 'StartAltitude': 1500, 'EndAltitude': 4500}, 'Supplied Power Ratio':{'phi_start': 0, 'phi_end':0 }},                  'Climb3': {'type': 'ConstantRateClimb', 'input': {'CB': 0.07, 'Speed': 125, 'StartAltitude': 4500, 'EndAltitude': 8000}, 'Supplied Power Ratio':{'phi_start': 0, 'phi_end':0 }},                  'Cruise': {'type': 'ConstantMachCruise', 'input':{ 'Mach': 0.4, 'Altitude': 8000}, 'Supplied Power Ratio':{'phi_start': 0, 'phi_end':0.5}},                  'Descent1': {'type': 'ConstantRateDescent', 'input':{'CB': -0.04, 'Speed': 90, 'StartAltitude': 8000, 'EndAltitude': 200}, 'Supplied Power Ratio':{'phi_start': 0.0, 'phi_end':0.0 }}}  DiversionStages = {'Climb1': {'type': 'ConstantRateClimb', 'input': {'CB': 0.08, 'Speed': 110, 'StartAltitude': 200, 'EndAltitude': 3100}, 'Supplied Power Ratio':{'phi_start': 0.0, 'phi_end':0.0 }},                  'Cruise': {'type': 'ConstantMachCruise', 'input':{ 'Mach': 0.35, 'Altitude': 3100}, 'Supplied Power Ratio':{'phi_start': 0.0, 'phi_end':0.0}},                  'Descent1': {'type': 'ConstantRateDescent', 'input':{'CB': -0.04, 'Speed': 90, 'StartAltitude': 3100, 'EndAltitude': 200}, 'Supplied Power Ratio':{'phi_start': 0.0, 'phi_end':0.0 }}}  In\u00a0[\u00a0]: Copied! <pre>EnergyInput = {'Ef': 43.5*10**6, # [J/kg]\n                   'Contingency Fuel': 130, # [kg]\n                   'Eta Gas Turbine Model': 'constant',\n                   'Eta Gas Turbine': 0.22,\n                   'Eta Gearbox': 0.96,\n                   'Eta Propulsive Model': 'constant',\n                   'Eta Propulsive': 0.9,\n                   'Eta Electric Motor 1': 0.96,    #for serial config\n                   'Eta Electric Motor 2': 0.96,    #for serial config\n                   'Eta Electric Motor': 0.98,      #for parallel config\n                   'Eta PMAD': 0.99,\n                   'Specific Power Powertrain': [3900,7700], # [W/kg] \n                   'Specific Power PMAD': [2200,2200,2200] # [W/kg]\n                   }\n</pre> EnergyInput = {'Ef': 43.5*10**6, # [J/kg]                    'Contingency Fuel': 130, # [kg]                    'Eta Gas Turbine Model': 'constant',                    'Eta Gas Turbine': 0.22,                    'Eta Gearbox': 0.96,                    'Eta Propulsive Model': 'constant',                    'Eta Propulsive': 0.9,                    'Eta Electric Motor 1': 0.96,    #for serial config                    'Eta Electric Motor 2': 0.96,    #for serial config                    'Eta Electric Motor': 0.98,      #for parallel config                    'Eta PMAD': 0.99,                    'Specific Power Powertrain': [3900,7700], # [W/kg]                     'Specific Power PMAD': [2200,2200,2200] # [W/kg]                    } In\u00a0[9]: Copied! <pre>CellInput = {\n    'Class': \"II\",\n    'Model':'Finger-Cell-Thermal', # used only if Class=II\n    'SpecificPower': 8000, # [W/kg] if Class=II it can be (i) assigned, or (ii) None and computed from cell properties\n    'SpecificEnergy': 1500, # [Wh/kg]\n    'Minimum SOC': 0.2,\n    'Pack Voltage':800, # [V] used only if Class=II\n    'Initial temperature': 25, # [\u00b0C] used only if Class=II\n    'Max operative temperature':50 # [\u00b0C] used only if Class=II\n    }\n</pre> CellInput = {     'Class': \"II\",     'Model':'Finger-Cell-Thermal', # used only if Class=II     'SpecificPower': 8000, # [W/kg] if Class=II it can be (i) assigned, or (ii) None and computed from cell properties     'SpecificEnergy': 1500, # [Wh/kg]     'Minimum SOC': 0.2,     'Pack Voltage':800, # [V] used only if Class=II     'Initial temperature': 25, # [\u00b0C] used only if Class=II     'Max operative temperature':50 # [\u00b0C] used only if Class=II     } In\u00a0[10]: Copied! <pre>AerodynamicsInput = {'AnalyticPolar': {'type': 'Quadratic', 'input': {'AR': 11, 'e_osw': 0.8}},\n                    'Take Off Cl': 1.9,\n                     'Landing Cl': 1.9,\n                     'Minimum Cl': 0.20,\n                     'Cd0': 0.017}\n</pre> AerodynamicsInput = {'AnalyticPolar': {'type': 'Quadratic', 'input': {'AR': 11, 'e_osw': 0.8}},                     'Take Off Cl': 1.9,                      'Landing Cl': 1.9,                      'Minimum Cl': 0.20,                      'Cd0': 0.017}  In\u00a0[11]: Copied! <pre>WellToTankInput = {'Eta Charge': 0.95,\n                   'Eta Grid': 1.,\n                   'Eta Extraction': 1.,\n                   'Eta Production': 1.,\n                   'Eta Transportation': 0.25}\n\nClimateImpactInput = {'H': 100, 'N':1.6e7, 'Y':30, 'EINOx_model':'Filippone', 'WTW_CO2': 8.30e-3, 'Grid_CO2': 9.36e-2}\n</pre> WellToTankInput = {'Eta Charge': 0.95,                    'Eta Grid': 1.,                    'Eta Extraction': 1.,                    'Eta Production': 1.,                    'Eta Transportation': 0.25}  ClimateImpactInput = {'H': 100, 'N':1.6e7, 'Y':30, 'EINOx_model':'Filippone', 'WTW_CO2': 8.30e-3, 'Grid_CO2': 9.36e-2} <p>Set aircraft power configuration and structural weight model</p> In\u00a0[12]: Copied! <pre>myaircraft.Configuration = 'Hybrid'\nmyaircraft.HybridType = 'Parallel'\nmyaircraft.weight.Class = 'I'\nmyaircraft.AircraftType = 'ATR'\n</pre> myaircraft.Configuration = 'Hybrid' myaircraft.HybridType = 'Parallel' myaircraft.weight.Class = 'I' myaircraft.AircraftType = 'ATR' <p>Import input dictionaries</p> In\u00a0[13]: Copied! <pre>myaircraft.ReadInput(AerodynamicsInput, \n                     ConstraintsInput,\n                     MissionInput,\n                     EnergyInput,\n                     MissionStages,\n                     DiversionStages, \n                     LoiterStages=None, \n                     WellToTankInput=WellToTankInput, \n                     CellInput=CellInput, \n                     ClimateImpactInput=ClimateImpactInput, \n                     PropellerInput=None\n                     )\n</pre> myaircraft.ReadInput(AerodynamicsInput,                       ConstraintsInput,                      MissionInput,                      EnergyInput,                      MissionStages,                      DiversionStages,                       LoiterStages=None,                       WellToTankInput=WellToTankInput,                       CellInput=CellInput,                       ClimateImpactInput=ClimateImpactInput,                       PropellerInput=None                      ) <p>Either run the Constraint Analysis....</p> In\u00a0[14]: Copied! <pre>myaircraft.constraint.FindDesignPoint()\nprint('----------------------------------------------')\nprint(f'Design wing loading W/S: {myaircraft.DesignWTOoS:.1f} [N/m^2]')\nprint(f'Design power-to-mass ratio P/W: {myaircraft.DesignPW:.2f} [W/kg]')\nprint('----------------------------------------------')\n</pre> myaircraft.constraint.FindDesignPoint() print('----------------------------------------------') print(f'Design wing loading W/S: {myaircraft.DesignWTOoS:.1f} [N/m^2]') print(f'Design power-to-mass ratio P/W: {myaircraft.DesignPW:.2f} [W/kg]') print('----------------------------------------------') <pre>----------------------------------------------\nDesign wing loading W/S: 3293.8 [N/m^2]\nDesign power-to-mass ratio P/W: 194.91 [W/kg]\n----------------------------------------------\n</pre> In\u00a0[15]: Copied! <pre>plt.plot(myaircraft.constraint.WTOoS,myaircraft.constraint.PWCruise, label='Cruise')\nplt.plot(myaircraft.constraint.WTOoS,myaircraft.constraint.PWTakeOff, label='Take Off')\nplt.plot(myaircraft.constraint.WTOoS,myaircraft.constraint.PWAEOClimb, label='Climb')\nplt.plot(myaircraft.constraint.WTOoS,myaircraft.constraint.PWOEIClimb, label='Climb OEI')\nplt.plot(myaircraft.constraint.WTOoS,myaircraft.constraint.PWTurn, label='Turn')\nplt.plot(myaircraft.constraint.WTOoS,myaircraft.constraint.PWCeiling, label='Ceiling')\nplt.plot(myaircraft.constraint.WTOoS,myaircraft.constraint.PWAcceleration, label='Acceleration')\nplt.plot(myaircraft.constraint.WTOoSLanding,myaircraft. constraint.PWLanding, label='Landing')\nplt.plot(myaircraft.DesignWTOoS, myaircraft.DesignPW, marker='o', markersize = 10, markerfacecolor = 'red', markeredgecolor = 'black')\n# plt.plot(performance.WTOoSTorenbeek, performance.PWTorenbeek, label='Torenbeek')\nplt.ylim([0, 300])\nplt.xlim([0, 7000])\nplt.legend()\nplt.grid(visible=True)\nplt.xlabel('$W_{TO}/S$')\nplt.ylabel('$P/W_{TO}$')\nplt.show()\n</pre> plt.plot(myaircraft.constraint.WTOoS,myaircraft.constraint.PWCruise, label='Cruise') plt.plot(myaircraft.constraint.WTOoS,myaircraft.constraint.PWTakeOff, label='Take Off') plt.plot(myaircraft.constraint.WTOoS,myaircraft.constraint.PWAEOClimb, label='Climb') plt.plot(myaircraft.constraint.WTOoS,myaircraft.constraint.PWOEIClimb, label='Climb OEI') plt.plot(myaircraft.constraint.WTOoS,myaircraft.constraint.PWTurn, label='Turn') plt.plot(myaircraft.constraint.WTOoS,myaircraft.constraint.PWCeiling, label='Ceiling') plt.plot(myaircraft.constraint.WTOoS,myaircraft.constraint.PWAcceleration, label='Acceleration') plt.plot(myaircraft.constraint.WTOoSLanding,myaircraft. constraint.PWLanding, label='Landing') plt.plot(myaircraft.DesignWTOoS, myaircraft.DesignPW, marker='o', markersize = 10, markerfacecolor = 'red', markeredgecolor = 'black') # plt.plot(performance.WTOoSTorenbeek, performance.PWTorenbeek, label='Torenbeek') plt.ylim([0, 300]) plt.xlim([0, 7000]) plt.legend() plt.grid(visible=True) plt.xlabel('$W_{TO}/S$') plt.ylabel('$P/W_{TO}$') plt.show() <p>... or manually assign a wing loading</p> In\u00a0[16]: Copied! <pre># myaircraft.DesignWTOoS = 3323\n</pre> # myaircraft.DesignWTOoS = 3323 <p>Run Mission analysis to define the aircraft's masses</p> In\u00a0[17]: Copied! <pre>myaircraft.weight.WeightEstimation()\n</pre> myaircraft.weight.WeightEstimation() <pre>max=58 and min=56\nOptimal n 57\nmax=341 and min=340\nOptimal n 341\nmax=119 and min=118\nOptimal n 119\nmax=125 and min=124\nOptimal n 125\nmax=125 and min=124\nOptimal n 125\nmax=125 and min=124\nOptimal n 125\nmax=125 and min=124\nOptimal n 125\n</pre> <p>Wing surface can be readily estimated as S = WTO/(WTO/S)</p> In\u00a0[18]: Copied! <pre>myaircraft.WingSurface = myaircraft.weight.WTO / myaircraft.DesignWTOoS * 9.81\n</pre> myaircraft.WingSurface = myaircraft.weight.WTO / myaircraft.DesignWTOoS * 9.81 <p>Well to tank impact is evaluated as a post-process</p> In\u00a0[19]: Copied! <pre>if (myaircraft.Configuration == 'Hybrid' and WellToTankInput is not None):\n    myaircraft.welltowake.EvaluateSource()\n</pre> if (myaircraft.Configuration == 'Hybrid' and WellToTankInput is not None):     myaircraft.welltowake.EvaluateSource() <p>A summary of the preliminary design:</p> In\u00a0[20]: Copied! <pre>myaircraft.Print_Aircraft_Design_Summary()\n</pre> myaircraft.Print_Aircraft_Design_Summary() <pre>Fuel mass (trip + altn + loiter): 1572.8 [Kg]\nBlock Fuel mass:                  1702.8 [Kg]\nBattery mass:                     1686.2 [Kg]\nStructure:                        12028.6 [Kg]\nPowertrain mass:                  1432.9 [Kg]\nEmpty Weight:                     15647.8 [Kg]\nZero Fuel Weight:                 20207.8 [Kg]\n----------------------------------------\nTakeoff Weight:                   21910.5 [Kg]\n \nSource Energy:                    281499.3 [MJ]\nPsi:                              0.0278 [-]\n \nWing Surface:                     65.3 [m^2]\n \nTakeOff engine shaft peak power:  4942.3 [KW]\nCLB/CRZ engine shaft peak power:  4072.2 [KW] @ 1503.5 [m]\n \nSizing phase for thermal powertrain:  Takeoff peak power\nThermal powertrain rating shaft power SLS rating: 4942.3 [kW]\n \n-------------Battery Specs-------------\nBattery Pack Energy:               2529.4 [kWh]\nBattery Pack Max Power:            13563.4 [kW]\nBattery Pack Specific Energy:      1500.0 [Wh/kg]\nBattery Pack Specific Power:       8.0 [kW/kg]\nBattery Configuration:             S-190 P-125\n</pre> <p>Tank to wake climate impact is evaluated as a post-process</p> In\u00a0[21]: Copied! <pre>myaircraft.MissionType = 'Continue'\nmyaircraft.climateimpact.calculate_mission_emissions()\nprint(myaircraft.climateimpact.mission_emissions)\n\nmyaircraft.climateimpact.ATR()\n</pre> myaircraft.MissionType = 'Continue' myaircraft.climateimpact.calculate_mission_emissions() print(myaircraft.climateimpact.mission_emissions)  myaircraft.climateimpact.ATR()  <pre>{'co2': 6271.1552711333725, 'h2o': 1981.711995716157, 'so4': 0.3145574596374852, 'soot': 0.06291149192749705, 'nox': 19.691116859261136}\n</pre> Out[21]: <pre>0.0028135789146068652</pre> <p>Some plots:</p> In\u00a0[22]: Copied! <pre>times = np.linspace(0,mission.profile.MissionTime2,num = 1000)\nplt.plot(times/60,[mission.profile.SuppliedPowerRatio(t) for t in times], 'b')\n#plt.plot(myaircraft.mission.profile.Breaks,np.ones(6)*0.05, '*')\nplt.grid(visible=True)\nplt.xlabel('t [min]')\nplt.ylabel('Phi')\nplt.show()\n</pre> times = np.linspace(0,mission.profile.MissionTime2,num = 1000) plt.plot(times/60,[mission.profile.SuppliedPowerRatio(t) for t in times], 'b') #plt.plot(myaircraft.mission.profile.Breaks,np.ones(6)*0.05, '*') plt.grid(visible=True) plt.xlabel('t [min]') plt.ylabel('Phi') plt.show() In\u00a0[23]: Copied! <pre>times = np.array([])\nEf    = np.array([])\nEbat  = np.array([])\nbeta  = np.array([])\nsoc   = np.array([])\nfor array in mission.integral_solution:\n    times = np.concatenate([times, array.t])\n    Ef    = np.concatenate([Ef   , array.y[0]])\n    Ebat  = np.concatenate([Ebat , array.y[1]])\n    beta  = np.concatenate([beta , array.y[2]])\n</pre> times = np.array([]) Ef    = np.array([]) Ebat  = np.array([]) beta  = np.array([]) soc   = np.array([]) for array in mission.integral_solution:     times = np.concatenate([times, array.t])     Ef    = np.concatenate([Ef   , array.y[0]])     Ebat  = np.concatenate([Ebat , array.y[1]])     beta  = np.concatenate([beta , array.y[2]]) <p>Takeoff propulsive power</p> In\u00a0[24]: Copied! <pre>myaircraft.performance.TakeOff(myaircraft.DesignWTOoS,myaircraft.constraint.TakeOffConstraints['Beta'], myaircraft.constraint.TakeOffConstraints['Altitude'],myaircraft.constraint.TakeOffConstraints['kTO'], myaircraft.constraint.TakeOffConstraints['sTO'], myaircraft.constraint.DISA, myaircraft.constraint.TakeOffConstraints['Speed'], myaircraft.constraint.TakeOffConstraints['Speed Type'])\n</pre> myaircraft.performance.TakeOff(myaircraft.DesignWTOoS,myaircraft.constraint.TakeOffConstraints['Beta'], myaircraft.constraint.TakeOffConstraints['Altitude'],myaircraft.constraint.TakeOffConstraints['kTO'], myaircraft.constraint.TakeOffConstraints['sTO'], myaircraft.constraint.DISA, myaircraft.constraint.TakeOffConstraints['Speed'], myaircraft.constraint.TakeOffConstraints['Speed Type']) Out[24]: <pre>194.88837279163596</pre> <p>Maximum mission Propusive Power over Takeoff Mass</p> In\u00a0[25]: Copied! <pre>max([myaircraft.performance.PoWTO(myaircraft.DesignWTOoS,beta[t],myaircraft.mission.profile.PowerExcess(times[t]),1,myaircraft.mission.profile.Altitude(times[t]),myaircraft.mission.DISA,myaircraft.mission.profile.Velocity(times[t]),'TAS') for t in range(len(times))])\n</pre> max([myaircraft.performance.PoWTO(myaircraft.DesignWTOoS,beta[t],myaircraft.mission.profile.PowerExcess(times[t]),1,myaircraft.mission.profile.Altitude(times[t]),myaircraft.mission.DISA,myaircraft.mission.profile.Velocity(times[t]),'TAS') for t in range(len(times))]) Out[25]: <pre>160.5799464672633</pre> In\u00a0[26]: Copied! <pre>plt.plot(times/60,[myaircraft.performance.PoWTO(myaircraft.DesignWTOoS,beta[t],myaircraft.mission.profile.PowerExcess(times[t]),1,myaircraft.mission.profile.Altitude(times[t]),myaircraft.mission.DISA,myaircraft.mission.profile.Velocity(times[t]),'TAS') for t in range(len(times))], 'b')\nplt.grid(visible=True)\nplt.xlabel('t [min]')\nplt.ylabel('Pp/W')\nplt.show()\n</pre> plt.plot(times/60,[myaircraft.performance.PoWTO(myaircraft.DesignWTOoS,beta[t],myaircraft.mission.profile.PowerExcess(times[t]),1,myaircraft.mission.profile.Altitude(times[t]),myaircraft.mission.DISA,myaircraft.mission.profile.Velocity(times[t]),'TAS') for t in range(len(times))], 'b') plt.grid(visible=True) plt.xlabel('t [min]') plt.ylabel('Pp/W') plt.show() In\u00a0[27]: Copied! <pre>plt.plot(times/60,[(myaircraft.weight.WTO/1000) * myaircraft.performance.PoWTO(myaircraft.DesignWTOoS,beta[t],myaircraft.mission.profile.PowerExcess(times[t]),1,myaircraft.mission.profile.Altitude(times[t]),myaircraft.mission.DISA,myaircraft.mission.profile.Velocity(times[t]),'TAS') for t in range(len(times))], 'b')\nplt.grid(visible=True)\nplt.xlabel('t [min]')\nplt.ylabel('Pp [kW]')\nplt.show()\n</pre> plt.plot(times/60,[(myaircraft.weight.WTO/1000) * myaircraft.performance.PoWTO(myaircraft.DesignWTOoS,beta[t],myaircraft.mission.profile.PowerExcess(times[t]),1,myaircraft.mission.profile.Altitude(times[t]),myaircraft.mission.DISA,myaircraft.mission.profile.Velocity(times[t]),'TAS') for t in range(len(times))], 'b') plt.grid(visible=True) plt.xlabel('t [min]') plt.ylabel('Pp [kW]') plt.show() In\u00a0[28]: Copied! <pre>plt.plot(times,Ef, 'b')\n#plt.plot(myaircraft.mission.profile.Breaks,np.ones(6)*0.05, '*')\nplt.grid(visible=True)\nplt.xlabel('t [min]')\nplt.ylabel('Efuel')\nplt.show()\n</pre> plt.plot(times,Ef, 'b') #plt.plot(myaircraft.mission.profile.Breaks,np.ones(6)*0.05, '*') plt.grid(visible=True) plt.xlabel('t [min]') plt.ylabel('Efuel') plt.show() In\u00a0[29]: Copied! <pre>plt.plot(times,beta, 'b')\n#plt.plot(myaircraft.mission.profile.Breaks,np.ones(6)*0.05, '*')\nplt.grid(visible=True)\nplt.xlabel('t [min]')\nplt.ylabel('beta')\nplt.show()\n</pre> plt.plot(times,beta, 'b') #plt.plot(myaircraft.mission.profile.Breaks,np.ones(6)*0.05, '*') plt.grid(visible=True) plt.xlabel('t [min]') plt.ylabel('beta') plt.show() In\u00a0[30]: Copied! <pre>plt.plot(times/60,mission.profile.Altitude(times))\nplt.grid(visible=True)\nplt.xlabel('t [min]')\nplt.ylabel('Altitude [m]')\nplt.show()\n</pre> plt.plot(times/60,mission.profile.Altitude(times)) plt.grid(visible=True) plt.xlabel('t [min]') plt.ylabel('Altitude [m]') plt.show()"},{"location":"getting-started/running-your-first-mission/#phlygreen-tutorial-sizing-a-parallel-hybrid-aircraft","title":"PhlyGreen Tutorial: sizing a parallel-hybrid aircraft\u00b6","text":""},{"location":"getting-started/theory/","title":"Theoretical Reference","text":"<p><code>PhlyGreen</code> (fl\u028c\u026a\u0261ri\u02d0n) is a Python object-oriented code for conducting preliminary design analysis on hybrid/electric aircraft. The <code>PhlyGreen</code> architecture facilitates the definition of Multidisciplinary Design Optimization (MDO) problems and the implementation of several discipline blocks into the optimization loop. </p>"},{"location":"getting-started/theory/#aircraft-preliminary-design-basics","title":"Aircraft preliminary design basics","text":"<p>The analysis starts from the point model energy balance equation obtained along the aircraft velocity direction:</p> \\[ \\frac{P_p}{W_{TO}} = g \\,\\frac{1}{W_{TO}/S}\\, q\\, V\\, C_D + \\beta\\, P_s, \\] <p>where \\(g\\) is the gravity acceleration, \\(q=1/2 \\rho V^2\\) is the dynamic pressure, \\(\\beta=W(t)/W_{TO}\\) is the instantaneous-to-take-off mass ratio, \\(C_D\\) is the drag coefficient, and \\(P_s\\) the specific excess power. The parameters \\(q\\),\\(C_D\\),\\(\\beta\\),\\(P_s\\) depend on the instantaneous flight condition, i.e., velocity \\(V\\), altitude \\(h\\) and attitude. More specifically, \\(C_D(C_L)\\) requires an aerodynamic polar model. The energy balance equation can be specified for each of the performance constraints denoted by the Top-level aircraft requirements (TLARs), designating a feasible space in terms of power-to-weight ratio \\(P_p/W_{TO}\\) and wing loading \\(W_{TO}/S\\). </p> <p>The powertrain model enables the generalization of the propulsive architecture. In fact, by considering the power flow pathways within a generic powertrain, a system of equations can be formulated as \\(\\sum P_{out} = \\sum \\eta_i P_{in,i}\\). If a hybrid parallel powertrain is considered, as done in the following, the linear system of equations is written as:</p> \\[ \\begin{bmatrix} -\\eta_{GT} &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; -\\eta_{GB} &amp; -\\eta_{GB} &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0  &amp; 1 &amp; -\\eta_{PM} &amp; 0 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 &amp; -\\eta_{EM} &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; -\\eta_P &amp; 0 &amp; 0 &amp; 1 \\\\ \\varphi &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \\varphi - 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1  \\end{bmatrix} \\begin{bmatrix}     P_f \\\\     P_{gt} \\\\     P_{gb} \\\\     P_{sh} \\\\     P_{e} \\\\     P_{bat} \\\\     P_p \\end{bmatrix} = \\begin{bmatrix}     0 \\\\     0 \\\\      0 \\\\     0 \\\\      0 \\\\     0 \\\\     P_p \\end{bmatrix} \\] <p>where </p> \\[ \\varphi = \\frac{P_{bat}}{P_{bat} + P_f} \\in [0, 1] \\] <p>is the instantaneous supplied power ratio, representing the portion of electrical power used by the engine on the total power reserve. In the system above, \\(\\eta_{GT}\\) is the gas-turbine turbo-shaft engine efficiency, \\(\\eta_{GB}\\) is the gearbox transmission efficiency, \\(\\eta_{EM}\\) is the electric motor efficiency, \\(\\eta_{PM}\\) is the power electronics efficiency, \\(\\eta_{P}\\) is the propeller efficiency, while \\(P_p\\) is the propulsive power (i.e. the power transmitted by the propeller to the airflow), \\(P_{sh}\\) is the shaft power (i.e. the power transmitted by the shaft to the propeller), \\(P_{gb}\\) is the gearbox transmitted power, \\(P_{gt}\\) is the power generated by the GT engine, \\(P_{e}\\) is the electric power generated by the electric motor, \\(P_{bat}\\) is the power required at the battery, and \\(P_f\\) is the power extracted from the fuel. To give a simple example, in a traditional configuration, the following chain holds:</p> \\[ P_f = \\frac{1}{\\eta_{GT}}\\cdot \\frac{1}{\\eta_{sh}} \\cdot \\frac{1}{\\eta_{GB}} \\cdot \\frac{1}{\\eta_{P}} \\cdot P_p. \\] <p>In other words, the efficiency chain amplifies the required aircraft power (due to drag) to a much higher fuel power. </p> <p>By solving the linear system above, the power-to-weight ratios referred to both fuel (P_f/W_{TO}) and battery (P_{bat}/W_{TO}) can be determined. These values can then be integrated in time along the mission profile to ascertain the cumulative energy contributions from the electric and fuel sources:</p> \\[ E_i = \\int_{t_s}^{t_e} \\frac{P_i}{W_{TO}} \\left( \\varphi(t), \\beta(t), h(t), V(t),\\frac{W_{TO}}{S} \\right) \\, W_{TO} \\, dt \\, , \\] <p>where the index \\(i\\) is representative of the fuel and battery sources. Note that the supplied power ratio \\(\\varphi\\) is an instantaneous quantity as well, which can be varied to define the most adequate hybridization strategy. </p> <p>The energy produced by burning fuel can be easily converted into the fuel weight \\(W_F\\) by using the fuel heating value, while the battery weight will be computed following two different methodologies: a) a low-fidelity formulation based on the most demanding scenario in terms of power and energy capacity along the mission profile and b) a higher-fidelity which accounts for the State-of-Charge (SoC) effects on a cell-level and computes the number of required serial and parallel cell numbers. The latter formulation is further discussed in Battery Module user guide.</p> <p>The total weight breakdown is completed by the operative empty weight (OEW) \\(W_{OE}\\) and payload \\(W_{PL}\\):</p> \\[ W_{TO} = W_{F} + W_{bat} + W_{PL} + W_{OE} \\; \\; , \\] <p>where </p> \\[ W_{OE} = W_{ST} + W_{PT} + W_{crew} \\; \\; . \\] <p>The structural weight \\(W_{ST}\\) can be estimated again following two approaches: a) a low-fidelity quick estimate based on empirical correlations between \\(W_{ST}\\) and \\(W_{TO}\\) of existing aircraft (class I); b) the more detailed estimations proposed in the FLOPS software, which consider the structural mass as the sum of the masses of several aircraft components (class II). The powertrain weight is estimated using the specific power of the components of the chosen architecture, considering the peak power requirement across the mission, take-off, and the TLARs. Given that the value of \\(W_{TO}\\) is needed in the intgeral equation above, the weight estimation necessitates an iterative procedure, such as Brent's method. The mission profile is modeled as a continuous function to integrate using the Backward differentiation formula (BDF) solver, an adaptive step method that does not rely on a priori time discretization of the mission.</p>"},{"location":"getting-started/theory/#references","title":"References","text":"<ul> <li>Roskam, J., Airplane Design, DARcorporation, 1985.</li> <li>Torenbeek, E., Synthesis of Subsonic Airplane Design: an Introduction to the Preliminary Design of Subsonic General Aviation and Transport Aircraft, with Emphasis on Layout, Aerodynamic Design, Propulsion and Performance, Springer Science &amp; Business Media, 2013</li> <li>Mattingly, J. D., Aircraft Engine Design, AIAA, 2002.</li> <li>Isikveren, A. T., Kaiser, S., Pornet, C., and Vratny, P. C., \u201cPre-design Strategies and Sizing Techniques for Dual-energy Aircraft,\u201d Aircraft Engineering and Aerospace Technology: An International Journal, Vol. 86, No. 6, 2014, pp. 525\u2013542.</li> <li>Pornet, C., Gologan, C., Vratny, P. C., Seitz, A., Schmitz, O., Isikveren, A. T., and Hornung, M., \u201cMethodology for Sizing and Performance Assessment of Hybrid Energy Aircraft,\u201d Journal of Aircraft, Vol. 52, No. 1, 2015, pp. 341\u2013352.</li> <li>Zamboni, J., Vos, R., Emeneth, M., and Schneegans, A., \u201cA Method for the Conceptual Design of Hybrid Electric Aircraft,\u201d AIAA Scitech 2019 Forum, 2019, p. 1587</li> <li>Orefice, F., Della Vecchia, P., Ciliberti, D., and Nicolosi, F., \u201cAircraft Conceptual Design Including Powertrain System Architecture and Distributed Propulsion,\u201d 2019 AIAA/IEEE Electric Aircraft Technologies Symposium (EATS), IEEE, 2019, pp.1\u201320</li> <li>de Vries, R., Brown, M. T., and Vos, R., \u201cA Preliminary Sizing Method for Hybrid-Electric Aircraft Including Aero-Propulsive Interaction Effects,\u201d 2018 Aviation Technology, Integration, and Operations Conference, 2018, p. 4228.</li> <li>De Vries, R., Brown, M., and Vos, R., \u201cPreliminary Sizing Method for Hybrid-Electric Distributed-Propulsion Aircraft,\u201d Journal of Aircraft, Vol. 56, No. 6, 2019, pp. 2172\u20132188</li> <li>Finger, D. F., Braun, C., and Bil, C., \u201cImpact of Engine Failure Constraints on the Initial Sizing of Hybrid-Electric GA Aircraft,\u201d AIAA Scitech 2019 Forum, 2019, p. 1812</li> <li>Proesmans, P.-J., and Vos, R., \u201cAirplane Design Optimization for Minimal Global Warming Impact,\u201d Journal of Aircraft, Vol. 59, No. 5, 2022, pp. 1363\u20131381</li> <li>Filippone, A., and Bojdo, N., \u201cStatistical Model for Gas Turbine Engines Exhaust Emissions,\u201d Transportation Research Part D: Transport and Environment, Vol. 59, 2018, pp. 451\u2013463</li> <li>Souleman Njoya Motapon, Alexandre Lupien-Bedard, Louis-A. Dessaint, Handy Fortin-Blanchette, and Kamal Al-Haddad. A Generic Electrothermal Li-ion Battery Model for Rapid Evaluation of Cell Temperature Temporal Evolution. IEEE Transactions on Industrial Electronics, 64(2):998\u20131008, 2017.</li> </ul>"},{"location":"user-guide/aircraft/","title":"Aircraft Model","text":"<p>This page documents the <code>Aircraft</code> class, the central container that coordinates constraint, mission, performance, systems, weight, climateimpact, and well\u2011to\u2011wake modules in PhlyGreen.</p>"},{"location":"user-guide/aircraft/#overview","title":"Overview","text":"<p>The <code>Aircraft</code> class is responsible for:</p> <ul> <li>Storing all high\u2011level aircraft configuration and inputs  </li> <li>Initializing subsystem models </li> <li>Passing inputs between these subsystems  </li> <li>Coordinating the full simulation workflow</li> </ul> <p>It acts as a data and logic hub, ensuring that all parts of the framework work with consistent and synchronized parameters.</p>"},{"location":"user-guide/aircraft/#key-attributes","title":"Key Attributes","text":""},{"location":"user-guide/aircraft/#configuration-parameters","title":"Configuration Parameters","text":"<ul> <li><code>Name</code> \u2014 aircraft name  </li> <li><code>Configuration</code> \u2014 <code>\"Traditional\"</code> or <code>\"Hybrid\"</code> </li> <li><code>HybridType</code> \u2014 <code>\"Serial\"</code> or <code>\"Parallel\"</code> (if hybrid)  </li> <li><code>Class</code> \u2014 weight estimation fidelity: <code>\"I\"</code> (simplified) or <code>\"II\"</code> (FLOPS\u2011based)</li> <li><code>AircraftType</code> \u2014 structural model selection</li> </ul>"},{"location":"user-guide/aircraft/#submodels","title":"Sub\u2011Models","text":"<p>The Aircraft object instantiation requires instances of the submodules classes as arguments:</p> <ul> <li><code>Systems.Powertrain</code> \u2014 gas\u2011turbine/electric/hybrid power models  </li> <li><code>Systems.Structures</code> \u2014 structural weight estimation model</li> <li><code>Systems.Aerodynamics</code> \u2014 aerodynamic polar model </li> <li><code>Performance</code> \u2014 aircraft performance equations  </li> <li><code>Mission</code> \u2014 mission simulation module and mission profile </li> <li><code>Weight</code> \u2014 global mass iteration loop </li> <li><code>Constraint</code> \u2014 constraint diagram equations </li> <li><code>WellToWake</code> \u2014 well\u2011to\u2011wake energy model (fuel + battery)</li> <li><code>Battery</code> \u2014 battery electro\u2011thermal model  </li> <li><code>ClimateImpact</code> \u2014 climate impact model</li> </ul> <p>Each is wired to the same parent aircraft instance.</p> <p></p>"},{"location":"user-guide/battery/","title":"Battery Model","text":"<p>This page documents the high\u2011fidelity electro\u2011thermal battery model in PhlyGreen.</p>"},{"location":"user-guide/battery/#overview","title":"Overview","text":"<p>PhlyGreen\u2019s Battery module provides a dynamic, temperature\u2011aware, physics\u2011based representation of a lithium\u2011ion battery pack suitable for hybrid\u2011electric aircraft preliminary design.</p> <p>It simulates:</p> <ul> <li>A representative cell, based on a modified Shepherd equation  </li> <li>Its thermal behaviour using a lumped\u2011parameter model  </li> <li>A complete battery pack, built via series (<code>S</code>) and parallel (<code>P</code>) configuration  </li> <li>Full operational constraint handling (voltage, SOC, current, temperature)  </li> <li>A sizing loop integrated into the aircraft\u2019s WTO iteration  </li> </ul> <p>The model is based on empirical cell parameters (selected in <code>Cell_Models</code>) and is configurable via user\u2011provided battery settings.</p>"},{"location":"user-guide/battery/#battery-state-variables","title":"Battery State Variables","text":"<p>At every timestep, the battery tracks three continuous state variables:</p> <ul> <li>Cell current: <code>i</code> </li> <li>Spent charge (Ah):  </li> </ul> <p>$$ i_t(t+\\Delta t) = i_t(t) + \\frac{i\\,\\Delta t}{3600} $$</p> <ul> <li>Temperature: \\( T \\)</li> </ul> <p>The State of Charge (SOC) is defined as:</p> \\[ \\text{SOC} = 1 - \\frac{i_t}{Q} \\] <p>where \\( Q \\) is the cell capacity.</p> <p>A <code>BatteryError</code> is raised if SOC leaves the allowable range:</p> \\[ \\text{SOC}_{\\min} \\le \\text{SOC} \\le 1 \\]"},{"location":"user-guide/battery/#pack-architecture","title":"Pack Architecture","text":"<p>A battery pack is constructed as:</p> <ul> <li><code>S</code> cells in series \u2192 increases voltage  </li> <li><code>P</code> cells in parallel \u2192 increases current capability  </li> </ul> <p>Thus:</p> \\[ V_{\\text{pack}} = S \\, V_{\\text{cell}} \\] \\[ I_{\\text{pack}} = P \\, i_{\\text{cell}} \\] <p>Pack-level capacity and energy:</p> \\[ Q_{\\text{pack}} = P \\, Q \\] \\[ E_{\\text{pack}} = S \\, P \\, E_{\\text{cell}} \\]"},{"location":"user-guide/battery/#cell-electrical-model","title":"Cell Electrical Model","text":""},{"location":"user-guide/battery/#modified-shepherd-equation-temperatureaware","title":"Modified Shepherd Equation (Temperature\u2011Aware)","text":"<p>The cell voltage is computed using a temperature\u2011corrected modified Shepherd model:</p> \\[ V = E_0(T)     - K(T)\\left(\\frac{Q}{Q - i_t}\\right)i_t     + A(T)e^{-B(T)i_t}     - i\\,R(T) \\] <p>Where:</p> <ul> <li>\\( E_0(T) \\) \u2014 open\u2011circuit voltage (with thermal correction)  </li> <li>\\( K(T) \\) \u2014 polarization constant  </li> <li>\\( A(T), B(T) \\) \u2014 exponential zone parameters  </li> <li>\\( R(T) \\) \u2014 internal resistance (Arrhenius\u2011corrected)  </li> </ul>"},{"location":"user-guide/battery/#solving-for-current-from-a-required-power","title":"Solving for Current from a Required Power","text":"<p>Given a required pack power \\( P_{\\text{pack}} \\), the battery solves:</p> \\[ P_{\\text{cell}} = \\frac{P_{\\text{pack}}}{S\\,P} \\] \\[ P_{\\text{cell}} = V(i)\\, i \\] <p>This becomes a quadratic equation:</p> \\[ a i^2 + b i + c = 0 \\] <p>Where:</p> <ul> <li>\\( a = -(R + K_r) \\) with \\( K_r = K Q/(Q-i_t) \\) </li> <li>\\( b = E_0 + A e^{-Bi_t} - i_t K_r \\) </li> <li>\\( c = -P_{\\text{cell}} \\)</li> </ul> <p>The physically meaningful root is selected:</p> \\[ i = \\frac{-b + \\sqrt{b^2 - 4ac}}{2a} \\] <p>If the discriminant is negative:</p> \\[ b^2 - 4ac &lt; 0 \\quad\\Rightarrow\\quad \\text{BatteryError} \\]"},{"location":"user-guide/battery/#thermal-model","title":"Thermal Model","text":""},{"location":"user-guide/battery/#lumpedparameter-singlenode-cell-temperature","title":"Lumped\u2011Parameter Single\u2011Node Cell Temperature","text":"<p>The cell temperature evolves according to:</p> \\[ \\frac{dT}{dt} = \\frac{Q_{\\text{loss}}}{C_{\\text{th}}}                + \\frac{T_{\\infty} - T}{R_{\\text{th}}\\, C_{\\text{th}}} \\] <p>Where:</p> <ul> <li>\\( C_{\\text{th}} \\) \u2014 thermal capacitance  </li> <li>\\( R_{\\text{th}} \\) \u2014 total thermal resistance  </li> </ul>"},{"location":"user-guide/battery/#heat-generation","title":"Heat Generation","text":"\\[ Q_{\\text{loss}} = (V_{\\text{oc}} - V)i + \\frac{dE_0}{dT} i T \\]"},{"location":"user-guide/battery/#convection-cooling-model","title":"Convection Cooling Model","text":"\\[ h = \\max\\left[ 30\\left(\\frac{\\dot{m}/(A_{\\text{surf}}\\rho)}{5}\\right)^{0.8},\\; 2 \\right] \\] <p>with airflow proportional to losses:</p> \\[ \\dot{m} = a \\, Q_{\\text{loss}} \\]"},{"location":"user-guide/battery/#battery-sizing-loop","title":"Battery Sizing Loop","text":"<p>Inside the aircraft\u2019s WTO root\u2011finding solver:</p> <ol> <li>Guess <code>WTO</code> </li> <li>Guess <code>P_number</code> </li> <li>Run full mission simulation  </li> <li>During each timestep, battery state is updated  </li> <li>If any violation occurs:  <ul> <li>SOC too low  </li> <li>Voltage too low  </li> <li>Current &gt; max  </li> <li>Temperature out of range \u2192 A <code>BatteryError</code> is thrown  </li> </ul> </li> <li>Increase <code>P_number</code> and retry  </li> <li>Once feasible, compute pack weight  </li> <li>Continue WTO iteration  </li> </ol> <p>This ensures size is based on actual in\u2011mission behaviour, not just averaged metrics.</p>"},{"location":"user-guide/battery/#inputs","title":"Inputs","text":"<p>Battery configuration comes from <code>CellInput</code>:</p> <ul> <li><code>\"Class\"</code> \u2014 <code>\"I\"</code> (simple) or <code>\"II\"</code> (electro\u2011thermal)  </li> <li><code>\"Model\"</code> \u2014 reference into <code>Cell_Models</code> </li> <li><code>\"SpecificEnergy\"</code> override  </li> <li><code>\"SpecificPower\"</code> override  </li> <li><code>\"Pack Voltage\"</code> </li> <li><code>\"Minimum SOC\"</code> </li> <li><code>\"Initial temperature\"</code> </li> <li><code>\"Max operative temperature\"</code></li> </ul> <p>Cell models include:</p> <ul> <li>Mass, size, geometry  </li> <li>OCV constants  </li> <li>Polarization coefficients  </li> <li>Exponential coefficients  </li> <li>Arrhenius constants  </li> <li>Thermal properties  </li> </ul>"},{"location":"user-guide/battery/#outputs","title":"Outputs","text":"<p>Available throughout the simulation:</p> <ul> <li><code>Vout</code> \u2014 pack voltage  </li> <li><code>cell_Vout</code> \u2014 cell voltage  </li> <li><code>I_pack</code> and <code>i_cell</code> \u2014 total and per\u2011cell current  </li> <li><code>SOC</code> </li> <li><code>T</code> </li> <li><code>Q_loss</code> \u2014 thermal losses  </li> <li>Pack mass, volume, energy  </li> <li>Maximum deliverable power  </li> </ul>"},{"location":"user-guide/battery/#error-handling","title":"Error Handling","text":"<p>The battery throws structured exceptions:</p> <ul> <li><code>\"SOC_OUTSIDE_LIMITS\"</code> </li> <li><code>\"VOLTAGE_OUTSIDE_LIMITS\"</code> </li> <li><code>\"CURR_OUTSIDE_LIMITS\"</code> </li> <li><code>\"NEG_BATT_TEMP\"</code> </li> <li><code>\"BATT_UNDERPOWERED\"</code> </li> <li><code>\"TEMP_OUTSIDE_LIMITS\"</code> </li> </ul> <p>These allow the sizing algorithm to automatically increase P.</p>"},{"location":"user-guide/battery/#usage-example","title":"Usage Example","text":"<pre><code>battery = Battery(aircraft)\nbattery.SetInput()\nbattery.Configure(parallel_cells=48)\n\nI = battery.Power_2_current(P=150e3)\ndTdt, Qloss = battery.heatLoss(Ta=288, rho=1.225)\n\nbattery.it += I * dt / 3600\nbattery.T  += dTdt * dt\n</code></pre>"},{"location":"user-guide/battery/#limitations","title":"Limitations","text":"<ul> <li>Single\u2011node temperature model (no spatial gradients).  </li> <li>No ageing/SEI model.  </li> <li>Cooling system mass is not sized.  </li> <li>Discharge\u2011only model (no charging).  </li> </ul>"},{"location":"user-guide/battery/#references","title":"References","text":"<ul> <li> <p>Shepherd, C. M. Design of Primary and Secondary Cells: II. An Equation Describing Battery Discharge.    Journal of The Electrochemical Society, 112(7):657, 1965.</p> </li> <li> <p>Tremblay, O., &amp; Dessaint, L.-A. A Generic Battery Model for the Dynamic Simulation of Hybrid Electric Vehicles.    Proceedings of the 2007 IEEE Vehicle Power and Propulsion Conference, pp. 284\u2013289.</p> </li> <li> <p>Saw, L., Somasundaram, K., Ye, Y., &amp; Tay, A. Electro-thermal analysis of Lithium Iron Phosphate battery for electric vehicles.    Journal of Power Sources, 249:231\u2013238, 2014.</p> </li> </ul>"},{"location":"user-guide/mission/","title":"Mission and Flight Profile Module","text":"<p>This page documents the Mission and Profile modules of PhlyGreen. These modules define the aircraft\u2019s flight profile, instantaneous power and overall energy consumption, and provide the temporal backbone used by all sizing routines (weight, battery, powertrain, emissions).</p>"},{"location":"user-guide/mission/#overview","title":"Overview","text":"<p>The mission solver integrates the aircraft state along a sequence of flight segments:</p> <ul> <li>climb  </li> <li>cruise  </li> <li>descent  </li> <li>loiter  </li> <li>diversion  </li> </ul> <p>Taxi and Take-off phases are presently not integrated in time, but accounted for with assigned fuel mass fractions.</p> <p>Each segment prescribes:</p> <ul> <li>altitude trajectory  </li> <li>speed schedule  </li> <li>load factor  </li> <li>electrical/thermal power split  </li> </ul> <p>The Profile module generates the time\u2011resolved reference states (altitude, speed, flight path angle), while the Mission module performs the powertrain requests, energy integration, and battery/fuel usage.</p>"},{"location":"user-guide/mission/#mission-class-highlevel-responsibilities","title":"Mission Class \u2014 High\u2011Level Responsibilities","text":"<p>The <code>Mission</code> class:</p> <ul> <li>Reads user mission inputs (<code>MissionInput</code> dictionary)</li> <li>Builds the flight profile via the <code>Profile</code> class</li> <li>Computes instantaneous power using aerodynamic and performance models</li> <li>Integrates:</li> <li>battery power  </li> <li>gas turbine power  </li> <li>Detects mission failures (insufficient power, battery issues)</li> <li>Returns mission total energies used for sizing</li> </ul>"},{"location":"user-guide/mission/#flight-profile-generation-profile-class","title":"Flight Profile Generation (Profile Class)","text":"<p>The <code>Profile</code> class discretizes the flight profile. It stores vectors of:</p> <ul> <li><code>altitude[t]</code></li> <li><code>speed[t]</code></li> <li><code>flight_path_angle[t]</code></li> <li><code>load_factor[t]</code></li> </ul> <p>It supports the following segments:</p> <ul> <li>Climb</li> <li>Cruise</li> <li>Descent</li> <li>Loiter</li> <li>Diversion</li> </ul> <p>Each segment appends time\u2011resolved states to the global mission arrays.</p>"},{"location":"user-guide/mission/#mission-power-calculation","title":"Mission Power Calculation","text":"<p>At each timestep \\( t \\), the Mission module computes the required propulsive power using the aircraft\u2019s <code>Performance</code> instance:</p> \\[ P_{prop}(t)= W_{TO} \\left[ \\frac{q V}{W_{TO}/S}\\, C_D(C_L, M) + \\beta P_s \\right] \\] <p>where:</p> <ul> <li>\\( q = \\frac{1}{2}\\rho V^2 \\) </li> <li>\\( W_{TO}/S \\) wing loading  </li> <li>\\( C_L, C_D \\) aerodynamic coefficients  </li> <li>\\( \\beta \\) = weight fraction  </li> <li>\\( P_s \\) = excess power requirement for climb  </li> </ul> <p>The Mission module then calls the Powertrain module to split this power into:</p> <ul> <li>fuel power  </li> <li>battery power  </li> </ul> <p>depending on the configured architecture (tradition, serial hybrid, parallel hybrid).</p>"},{"location":"user-guide/mission/#energy-integration","title":"Energy Integration","text":""},{"location":"user-guide/mission/#battery-energy","title":"Battery Energy","text":"<p>The integrated battery power request yields:</p> \\[ E_{bat}(t+\\Delta t) = E_{bat}(t) +  \\int_{t}^{t+\\Delta t} \\frac{P_{bat}}{W_{TO}} \\left( \\varphi(t), \\beta(t), h(t), V(t),\\frac{W_{TO}}{S} \\right) \\, W_{TO} \\, dt \\, , \\] <p>where \\( P_{\\text{bat}} \\) is given by processing the propulsive power with the electrical efficiency chain.  If the Class II battery model is used, the current is computed:</p> \\[ I(t) = \\text{Battery.Power_2_current}(P_{\\text{bat}}) \\] <p>and the SOC evolution is:</p> \\[ \\text{SOC}(t+\\Delta t) = 1 - \\frac{i_t(t)+ I\\Delta t/3600}{Q} \\] <p>Battery temperature uses the thermal ODE:</p> \\[ \\frac{dT}{dt} = \\frac{Q_{\\text{loss}}}{C_{\\text{th}}} + \\frac{T_\\infty - T}{R_{\\text{th}}C_{\\text{th}}} \\]"},{"location":"user-guide/mission/#fuel-energy","title":"Fuel Energy","text":"<p>Fuel energy integration:</p> \\[ E_f(t+\\Delta t) = E_f(t) +  \\int_{t}^{t+\\Delta t} \\frac{P_f}{W_{TO}} \\left( \\varphi(t), \\beta(t), h(t), V(t),\\frac{W_{TO}}{S} \\right) \\, W_{TO} \\, dt \\, , \\] <p>where the fuel power is obtained by amplifying the propulsive power with the thermal efficiency chain.</p>"},{"location":"user-guide/mission/#segment-loop-core-mission-logic","title":"Segment Loop (Core Mission Logic)","text":"<p>Pseudocode equivalent to the Mission solver:</p> <pre><code>for each timestep t in mission_profile:\n    read altitude, speed, gamma\n    compute performance propulsive power Pp\n    request powertrain split\n    update fuel and battery states\n    check SOC, voltage, current, T\n    accumulate segment energy\n</code></pre> <p>If any constraint is violated, a <code>MissionError</code> or <code>BatteryError</code> is thrown, causing the aircraft sizing loop to increase P\u2011number or adjust weight.</p>"},{"location":"user-guide/mission/#mission-outputs","title":"Mission Outputs","text":"<p>After integrating the full mission, the module returns:</p> <ul> <li>Total mission fuel energy  </li> <li>Total mission battery energy  </li> <li>Total emissions (if enabled)  </li> <li>Segment\u2011by\u2011segment logs (power, altitude, speed, SOC, T)  </li> <li>Peak power requirements  </li> <li>Mission duration  </li> <li>Required reserve energy  </li> <li>Whether mission constraints were satisfied  </li> </ul> <p>These outputs feed directly into:</p> <ul> <li>Powertrain Sizing </li> <li>Battery Sizing </li> <li>WTO iteration </li> <li>Emissions accounting </li> <li>Well\u2011to\u2011Wake energy evaluation</li> </ul>"},{"location":"user-guide/mission/#usage-example","title":"Usage Example","text":"<pre><code>mission = aircraft.mission\nmission.SetInput()           # load MissionInput dictionary\nmission.InitializeProfile()       # generate profile\nresults = mission.EvaluateMission(WTO) # integrate energy and power use\n</code></pre>"},{"location":"user-guide/mission/#limitations","title":"Limitations","text":"<ul> <li>Flight mechanics are 1\u2011D (no lateral simulation)  </li> <li>Weather and airport constraints not included  </li> </ul>"},{"location":"user-guide/performance/","title":"Performance Module","text":"<p>The performance module provides all low-level performance computations for an aircraft within the conceptual design loop: speed conversions, aerodynamic state evaluation, power-to-weight constraints, take-off, landing, ceiling, climb, turn, and acceleration requirements.</p> <p>The Performance class centralizes all the physics relating thrust/power, speed, lift, drag, and mission requirements. It is meant to be used inside the Constraint analysis and Mission modules.</p> <p>The key responsibilities of the Performance class are:</p> <ul> <li>Convert between Mach, CAS, TAS, KCAS, KTAS using ISA atmosphere and units</li> <li>Compute dynamic pressure, lift coefficient, drag coefficient, exploiting the aircraft aerodynamics module</li> <li>Compute required Power-to-Weight ratio (PoWTO) for a generic flight condition, plus phase-specific P/W ratios for the constraint analysis:<ul> <li>One-Engine-Inoperative (OEI) climb</li> <li>Ceiling Rate-of-Climb (ROC) requirement</li> <li>Take-off field length</li> <li>Landing approach/stall constraint (gives W/S max)</li> <li>Finger methods (Torenbeek / Raymer-like approximations)</li> </ul> </li> </ul>"},{"location":"user-guide/performance/#generic-power-to-weight-ratio","title":"Generic Power-to-Weight ratio","text":"<pre><code>def PoWTO(self, WTOoS, beta, Ps, n, altitude, DISA, speed, speedtype):\n    #...\n</code></pre> <p>This method computes the required power-to-weight ratio \\( P/W_{TO} \\) for a generic steady flight or climb condition. Note that the power-to-weight ratio is computed with reference to the takeoff weight \\( W_{TO} \\).</p> <p>Inputs</p> <ul> <li><code>WTOoS</code>: wing loading \\( W_{TO} / S \\) [N/m\u00b2].</li> <li><code>beta</code>: weight fraction \\( \\beta = W / W_{TO} \\).</li> <li><code>Ps</code>: required specific excess power (e.g. for climb), in m/s.</li> <li><code>n</code>: load factor.</li> <li><code>altitude</code>, <code>DISA</code>, <code>speed</code>, <code>speedtype</code>: define the operating point.</li> </ul> <p>Algorithm</p> <ol> <li>Call <code>set_speed</code> to compute Mach and TAS for the given condition.</li> <li>Compute dynamic pressure:    \\[ q = \\tfrac{1}{2} \\, \\rho(h,\\Delta T) \\, V^2. \\]</li> <li>Compute lift coefficient from vertical equilibrium:    \\[ C_L = \\frac{n \\, \\beta \\, (W_{T0}/S)}{q}. \\]</li> <li>Get drag coefficient from the aircraft polar (see Aerodynamics):    \\[ C_D = C_D(C_L, M). \\]</li> <li>Compute required power-to-weight:</li> </ol> <pre><code>PW = self.g_acc * (1.0/WTOoS * q * self.TAS * Cd + beta * Ps)\n</code></pre> <p>which corresponds to</p> <p>\\[    \\frac{P}{W_{TO}} = g\\left[      \\frac{q \\, V}{W_{TO}/S} C_D + \\beta P_s    \\right].    \\]</p> <pre><code>where the power-to-weight ratio is expressed in [W/kg]\n</code></pre>"},{"location":"user-guide/performance/#phase-specific-power-to-weight-ratios","title":"Phase-specific Power-to-Weight ratios","text":""},{"location":"user-guide/performance/#1-oei-climb","title":"1. OEI Climb","text":"<pre><code>def OEIClimb(self, WTOoS, beta, Ps, n, altitude, DISA, speed, speedtype):\n    #...\n</code></pre> <p>This method implements the one-engine-inoperative (OEI) climb constraint. It uses the same structure as <code>PoWTO</code>, but multiplies the result by the factor \\( n_{eng}/(n_{eng} - 1) \\) to model the loss of one engine.</p> <p>Hence, OEI climb yields:</p> \\[ \\left(\\frac{P}{W_{TO}}\\right)_{\\text{OEI}} = \\frac{n_{eng}}{n_{eng}-1} \\, g\\left[\\frac{qV}{W_{TO}/S}C_D + \\beta P_s\\right]. \\]"},{"location":"user-guide/performance/#2-ceiling","title":"2. Ceiling","text":"<pre><code>def Ceiling(self, WTOoS, beta, Ps, n, altitude, DISA, MachC):\n    #...\n</code></pre> <p>This method computes the power-to-weight required to satisfy a given rate of climb at the service ceiling altitude.</p> <p>Inputs</p> <ul> <li><code>WTOoS</code>, <code>beta</code>, <code>Ps</code>, <code>n</code>: as in <code>PoWTO</code>.</li> <li><code>altitude</code>, <code>DISA</code>: service ceiling conditions.</li> <li><code>MachC</code>: Mach number at ceiling (used for drag and dynamic pressure).</li> </ul> <p>Key relations</p> <ol> <li>Compute ceiling TAS from a characteristic max-efficiency lift coefficient \\( C_{L,E} \\):</li> </ol> <p>\\[    V_{ceiling} =    \\sqrt{      \\frac{2 \\beta (W_{TO}/S)}{\\rho(h, \\Delta T) \\, C_{L,E}(M_C)}    }.    \\]</p> <ol> <li>Dynamic pressure using Mach:</li> </ol> <p>\\[    q = \\tfrac12 \\, \\gamma \\, p(h) \\, M_C^2    \\]</p> <ol> <li>Lift and drag coefficients:</li> </ol> <p>\\[ C_L = \\frac{n\\beta(W_{TO}/S)}{q}, \\qquad C_D = C_D(C_L, M_C). \\]</p> <ol> <li>Required power-to-weight:</li> </ol> <p>\\[    \\frac{P}{W_{TO}} = g\\left[ \\frac{q \\, V_{ceiling}}{W_{TO}/S} C_D + \\beta P_s \\right].    \\]</p>"},{"location":"user-guide/performance/#3-takeoff-mattingly","title":"3. Takeoff (Mattingly)","text":"<pre><code>def TakeOff(self, WTOoS, beta, altitudeTO, kTO, sTO, DISA, speed, speedtype):\n    #...\n</code></pre> <p>This method implements a Mattingly-style takeoff field length constraint for power-to-weight.</p> <p>Inputs</p> <ul> <li><code>WTOoS</code>: wing loading \\( W_{T0}/S \\).</li> <li><code>beta</code>: takeoff weight fraction.</li> <li><code>altitudeTO</code>: takeoff altitude.</li> <li><code>kTO</code>: ratio \\( V_{TO} / V_{S,TO} \\).</li> <li><code>sTO</code>: required takeoff field length.</li> <li><code>DISA</code>: temperature deviation at takeoff.</li> <li><code>speed</code>, <code>speedtype</code>: define TAS used as <code>V_TO</code>.</li> </ul> <p>Core relationship in the code:</p> <pre><code>PW = self.TAS * beta**2 * WTOoS * (kTO**2) / (\n        sTO * ISA.atmosphere.RHOstd(altitudeTO, DISA)\n             * self.aircraft.aerodynamics.Cl_TO\n     )\n</code></pre> <p>Mathematically:</p> <p>\\[  \\frac{P}{W_{TO}} =  V_{TO}  \\frac{\\beta^2 (W_{TO}/S) k_{TO}^2}{s_{TO} \\, \\rho(h_{TO}, \\Delta T) \\, C_{L,TO}}.  \\]</p>"},{"location":"user-guide/performance/#4-takeoff-torenbeek","title":"4. Takeoff (Torenbeek)","text":"<pre><code>def TakeOff_TORENBEEK(self, altitudeTO, sTO, fTO, hTO, V3oVS, mu,\n                      speed, speedtype, DISA):\n    #...\n</code></pre> <p>This method generates a parametric (P/W, W/S) curve for takeoff using Torenbeek's analytical approach.</p> <p>Inputs</p> <ul> <li><code>altitudeTO</code>: takeoff altitude.</li> <li><code>sTO</code>: required takeoff distance.</li> <li><code>fTO</code>: fraction of field length for ground run.</li> <li><code>hTO</code>: obstacle height.</li> <li><code>V3oVS</code>: speed ratio (e.g. certification-related).</li> <li><code>mu</code>: ground friction coefficient.</li> <li><code>speed</code>, <code>speedtype</code>, <code>DISA</code>: define TAS at takeoff.</li> </ul> <p>Algorithm sketch</p> <ol> <li>Use <code>set_speed</code> to compute TAS at TO.</li> <li>Define a range of P/W values:</li> </ol> <pre><code>PW = np.linspace(1, 300, num=100)\nToWTO = PW / self.TAS\n</code></pre> <ol> <li>Approximate the lift-off climb angle:</li> </ol> <pre><code>gammaLOF = 0.9 * ToWTO - 0.3/np.sqrt(self.aircraft.aerodynamics.AR)\n</code></pre> <ol> <li>Adjust friction including lift:</li> </ol> <pre><code>mu1 = mu + 0.01 * self.aircraft.aerodynamics.ClMax\n</code></pre> <ol> <li>Solve analytically for \\( W_{T0}/S \\) as function of P/W_{TO} (closed-form formula in the code).    The result is an array <code>WTOoS</code> such that each pair <code>(PW[i], WTOoS[i])</code> lies on the    Torenbeek takeoff constraint.</li> </ol>"},{"location":"user-guide/performance/#5-takeoff-finger","title":"5. Takeoff (Finger)","text":"<pre><code>def TakeOff_Finger(self, WTOoS, beta, altitudeTO, kTO, sTO, DISA, speed, speedtype):\n    #...\n</code></pre> <p>This method uses Finger's analytical approach for takeoff power-to-weight. From the structure of the code, it computes:</p> <pre><code>self.set_speed(altitudeTO, speed, speedtype, DISA)\nPW = self.TAS * (\n    1.21 * WTOoS / (sTO * ISA.atmosphere.RHOstd(altitudeTO, DISA)\n                    * self.aircraft.aerodynamics.ClTO * self.g_acc)\n    + 1.21 * self.aircraft.aerodynamics.Cd(self.aircraft.aerodynamics.ClTO, self.Mach)\n            / self.aircraft.aerodynamics.ClTO\n    + 0.21 * 0.04\n)\n</code></pre> <p>The corresponding expression is:</p> <p>\\[  \\frac{P}{W_{TO}} = V_{TO} \\Bigg[    1.21 \\, \\frac{W_{TO}/S}{s_{TO} \\, \\rho \\, C_{L,TO} \\, g}   + 1.21 \\, \\frac{C_{D,TO}}{C_{L,TO}}   + 0.21 \\times 0.04  \\Bigg],  \\]</p> <p>where \\( C_{D,TO} = C_D(C_{L,TO}, M) \\). The terms account for:</p> <ul> <li>ground roll constraint;</li> <li>climb-out over obstacle;</li> <li>additional margin / safety term.</li> </ul>"},{"location":"user-guide/performance/#6-landing-mattingly","title":"6. Landing (Mattingly)","text":"<p>This method encodes the landing constraint, typically used to determine a maximum allowable wing loading \\( (W_{T0}/S)_{max,landing} \\). The implementation uses standard relations:</p> <ul> <li>Stall speed in landing configuration:   \\[ V_{S,L} = \\sqrt{\\frac{2 (W_{TO}/S)}{\\rho C_{L,max,L}}}. \\]</li> <li>Approach speed:   \\[ V_{app} \\approx 1.3 V_{S,L}. \\]</li> </ul> <p>Given a maximum allowed approach speed or landing distance, the method limits the wing loading accordingly. In a constraint diagram this becomes a vertical line at \\( W_{TO}/S = (W_{TO}/S)_{max,landing} \\).</p>"},{"location":"user-guide/performance/#7-climb-finger","title":"7. Climb (Finger)","text":"<pre><code>def ClimbFinger(self, WTOoS, beta, Ps, n, altitude, DISA, speed, speedtype):\n    #...\n</code></pre> <p>This method implements Finger's analytical climb approximation. Instead of numerically searching the best climb speed, it uses closed-form expressions derived from the drag polar.</p> <p>Key ingredients from the code:</p> <ul> <li>Induced drag factor:   <pre><code>k = self.aircraft.aerodynamics.ki()\n</code></pre></li> <li>Zero-lift drag \\( C_{D0}(M) \\) and minimum lift coefficient \\( C_{L,min} \\).</li> </ul> <p>The method computes a characteristic speed \\( V_{L/D} \\) and a helper quantity \\( H \\), then obtains an approximate optimum climb speed:</p> <p>\\[  V = \\sqrt{ H - \\sqrt{H^2 - V_{L/D}^4} }.  \\]</p> <p>At this speed, dynamic pressure and drag are computed and plugged into a PoW expression similar to <code>PoWTO</code>:</p> <p>\\[  \\frac{P}{W_{TO}} = g\\left[ \\frac{q V}{W_{TO}/S} C_D^{Finger} + \\beta P_s \\right],  \\]</p> <p>producing an explicit climb constraint without a numeric optimization.</p>"},{"location":"user-guide/performance/#8-oei-climb-finger","title":"8. OEI Climb (Finger)","text":"<pre><code>def OEIClimbFinger(self, WTOoS, beta, Ps, n, altitude, DISA, speed, speedtype):\n    #...\n</code></pre> <p>This is the OEI version of <code>ClimbFinger</code>. It uses the same analytical Finger approximation and then applies the OEI factor:</p> \\[ \\left(\\frac{P}{W_{TO}}\\right)_{\\text{OEI,Finger}} = \\frac{n_{eng}}{n_{eng}-1} \\, g\\left[ \\frac{q V}{W_{TO}/S} C_D^{Finger} + \\beta P_s \\right]. \\]"},{"location":"user-guide/performance/#speed-conversion","title":"Speed Conversion","text":"<pre><code>def set_speed(self, altitude, speed, speedtype, DISA):\n    # fills Mach, TAS, CAS, KTAS, KCAS from one given speed\n    #...\n</code></pre> <p>Inputs</p> <ul> <li><code>altitude</code> [m]: flight altitude.</li> <li><code>speed</code>: numeric value of the given speed.</li> <li><code>speedtype</code>: one of <code>'Mach'</code>, <code>'TAS'</code>, <code>'CAS'</code>, <code>'KTAS'</code>, <code>'KCAS'</code>.</li> <li><code>DISA</code>: ISA temperature deviation (delta ISA).</li> </ul> <p>Depending on <code>speedtype</code>, the method uses functions in <code>Speed</code> and <code>Units</code> to convert between all speed representations. Typical relations:</p> <ul> <li>If <code>speedtype == 'Mach'</code>:</li> <li>Set Mach:  \\( M = s \\).</li> <li>Compute TAS:  \\( V_{TAS} = f_M(M, h, \\Delta T) \\).</li> <li> <p>Compute CAS from TAS:  \\( V_{CAS} = f_{TC}(V_{TAS}, h, \\Delta T) \\).</p> </li> <li> <p>If <code>speedtype == 'TAS'</code>:</p> </li> <li>Set TAS:  \\( V_{TAS} = s \\).</li> <li>Compute Mach:  \\( M = f_{MT}(V_{TAS}, h, \\Delta T) \\).</li> <li>Compute CAS:  \\( V_{CAS} = f_{TC}(V_{TAS}, h, \\Delta T) \\).</li> </ul> <p>and similarly for <code>CAS</code>, <code>KTAS</code>, <code>KCAS</code> by appropriate inversion.</p> <p>After this call,</p> <ul> <li><code>self.Mach</code>, <code>self.TAS</code>, <code>self.CAS</code>, <code>self.KTAS</code>, <code>self.KCAS</code></li> </ul> <p>are all consistent at the given <code>altitude</code> and <code>DISA</code>.</p>"},{"location":"user-guide/powertrain/","title":"Powertrain Module","text":"<p>The Powertrain module computes powertrain performance throughout the mission and distributes power across thermal and electrical subsystems depending on the aircraft configuration (Traditional, Serial Hybrid, or Parallel Hybrid).  </p>"},{"location":"user-guide/powertrain/#overview","title":"Overview","text":"<p>The Powertrain model:</p> <ul> <li>Converts a given propulsive power requirement into fuel power and electric power (the latter if hybrid)</li> <li>To do so, it builds architecture-specific powertrain efficiency-chains using components efficiencies (see the Theoretical Reference)</li> <li>Components efficiencies are computed based on the current flight conditions, if a model is provided. Otherwise, constant, user-specified values are used.</li> <li>Presently, the available component models are:<ul> <li>Hamilton model for propeller efficiency, computed as a function of true airspeed, altitude, and power request </li> <li>A surrogate response function of a twin-spool gas-turbine engine thermal efficiency, computed as a function of true airspeed, altitude, and power request </li> </ul> </li> <li>Computes powertrain mass from subsystem specific powers</li> <li>Provides a GT engine power-lapse with altitude, to be used for constraint evaluation and engine rating</li> </ul> <p>The powertrain system performance is evaluated at every timestep during the Mission integration.</p>"},{"location":"user-guide/powertrain/#power-ratios","title":"Power Ratios","text":"<p>The main objective of the powertrain module is to compute the fuel/battery power required to deliver a certain propulsive power. At any instant in time, the required propulsive power is computed by the Mission module (see Mission):</p> \\[ P_{prop}(t)= W_{TO} \\left[ \\frac{q V}{W_{TO}/S}\\, C_D(C_L, M) + \\beta P_s \\right] \\] <p>where \\(q\\) is the dynamic pressure, \\(W_{TO}\\) is the takeoff weight, \\(S\\) is the wing area, \\(C_D(C_L, M)\\) is the drag coefficient given by the polar model, \\(\\beta\\) is the weight fraction, and \\(P_s\\) is the power excess required for climb.</p> <p>Depending on the powerplant architecture, the required fuel/battery powers are computed as follows:</p>"},{"location":"user-guide/powertrain/#1-traditional","title":"1. Traditional","text":"<p>The system solves for the following power ratios:</p> <ul> <li>\\( \\displaystyle \\frac{P_f}{P_p} \\): fuel power to propulsive power  </li> <li>\\( \\displaystyle \\frac{P_{gt}}{P_p} \\): gas-turbine shaft power to propulsive power  </li> <li>\\( \\displaystyle \\frac{P_{gb}}{P_p} \\): gearbox output power to propulsive power  </li> <li>\\( \\displaystyle \\frac{P_p}{P_p} = 1 \\): reference value</li> </ul> <p>These represent the power chain:</p> <p>Fuel \u2192 Gas Turbine \u2192 Gearbox \u2192 Propeller \u2192 Propulsive Power</p> <p>The power flow is represented as:</p> \\[ A\\,x = b , \\] <p>where the upper-triangular matrix \\(A\\) is:</p> \\[ A = \\begin{bmatrix} -\\,\\eta_{GT} &amp; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; -\\,\\eta_{GB} &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; -\\,\\eta_{PP} &amp; 1 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix}, \\qquad b = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 1 \\end{bmatrix}. \\] <p>where \\(\\eta_{GT}\\), \\(\\eta_{GB}\\), and \\(\\eta_{PP}\\) are the gas-turbine, gearbox, and propeller efficiencies, respectively. The solution vector \\(x\\) is:</p> \\[ x = \\begin{bmatrix} P_f/P_p \\\\ P_{gt}/P_p \\\\ P_{gb}/P_p \\\\ 1 \\end{bmatrix}. \\] <p>Because \\(A\\) is upper-triangular, the solution corresponds to the sequential efficiency chain.</p> <ol> <li>Gearbox &lt;- Propeller</li> </ol> \\[ \\frac{P_{gb}}{P_p} = \\frac{1}{\\eta_{PP}} \\] <ol> <li>Gas Turbine &lt;- Gearbox</li> </ol> \\[ \\frac{P_{gt}}{P_p} = \\frac{1}{\\eta_{GB}\\,\\eta_{PP}} \\] <ol> <li>Fuel &lt;- Gas Turbine</li> </ol> \\[ \\frac{P_f}{P_p} = \\frac{1}{\\eta_{GT}\\,\\eta_{GB}\\,\\eta_{PP}} \\] <p>Thus, the system computes the inverse cumulative efficiencies needed to deliver \\(P_p\\). The calculation is performed using the following code, that solves the linear system \\(A\\,x = b\\):</p> <pre><code>A = np.array([\n    [-self.EtaGTmodel(alt, vel, pwr), 1, 0, 0],\n    [0, -self.EtaGB, 1, 0],\n    [0, 0, -self.EtaPPmodel(alt, vel, pwr), 1],\n    [0, 0, 0, 1]\n])\n\nb = np.array([0, 0, 0, 1])\n\nPowerRatio = np.linalg.solve(A, b)\n</code></pre> <p>yielding the power ratios vector: \\(P_f/P_p, \\ P_{gt}/P_p, \\  P_{gb}/P_p, \\  P_p/P_p\\). Both \\(\\eta_{PP}\\) and \\(\\eta_{GT}\\) can be computed as functions of the flight conditions or left as constants (default). To use the models, the user must select the following options in the EnergyInput:</p>"},{"location":"user-guide/powertrain/#energyinput-eta-propulsive-model-hamilton-eta-gt-model-pw127-other-options","title":"<pre><code>EnergyInput = {\n    'Eta Propulsive Model': 'Hamilton',\n    'Eta GT Model': 'PW127',\n    # ... other options\n}\n</code></pre>","text":""},{"location":"user-guide/powertrain/#2-serial-hybrid","title":"2. Serial Hybrid","text":"<p>The system solves for the following power ratios:</p> <ul> <li>\\( \\displaystyle \\frac{P_f}{P_p} \\): fuel power to propulsive power  </li> <li>\\( \\displaystyle \\frac{P_{gt}}{P_p} \\): gas-turbine shaft power to propulsive power  </li> <li>\\( \\displaystyle \\frac{P_{gb}}{P_p} \\): gearbox output power to propulsive power  </li> <li>\\( \\displaystyle \\frac{P_{e1}}{P_p} \\): electric generator power to propulsive power  </li> <li>\\( \\displaystyle \\frac{P_{e2}}{P_p} \\): electric motor power to propulsive power  </li> <li>\\( \\displaystyle \\frac{P_{bat}}{P_p} \\): battery power to propulsive power  </li> <li>\\( \\displaystyle \\frac{P_{s2}}{P_p} \\): shaft power to propulsive power  </li> <li>\\( \\displaystyle \\frac{P_p}{P_p} = 1 \\): reference value</li> </ul> <p>with reference to the power chain in the image below:</p> <p></p> <p>The power flow is represented as:</p> \\[ A\\,x = b , \\] <p>where the matrix \\(A\\) is:</p> \\[ A = \\begin{bmatrix} -\\eta_{\\mathrm{GT}} &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\[6pt] 0 &amp; -\\eta_{\\mathrm{EM1}} &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\[6pt] 0 &amp; 0 &amp; 0 &amp; -\\eta_{\\mathrm{PM}} &amp; 1 &amp; -\\eta_{\\mathrm{PM}} &amp; 0 &amp; 0 \\\\[6pt] 0 &amp; 0 &amp; 1 &amp; 0 &amp; -\\eta_{\\mathrm{EM2}} &amp; 0 &amp; 0 &amp; 0 \\\\[6pt] 0 &amp; 0 &amp; -\\eta_{\\mathrm{GB}} &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\\\[6pt] 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; -\\eta_{\\mathrm{PP}}(h,V,P) &amp; 1 \\\\[6pt] \\phi &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \\phi - 1 &amp; 0 &amp; 0 \\\\[6pt] 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\] \\[ b = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 1 \\end{bmatrix} \\] <p>The solution vector \\(x\\) is:</p> \\[ x = \\begin{bmatrix} P_f/P_p \\\\ P_{gt}/P_p \\\\ P_{gb}/P_p \\\\ P_{e1}/P_p \\\\ P_{e2}/P_p \\\\ P_{bat}/P_p \\\\ P_{s2}/P_p \\\\ P_p/P_p \\end{bmatrix}. \\] <p>The calculation is performed using the following code, that solves the linear system \\(A\\,x = b\\):</p> <pre><code>A = np.array([[- self.EtaGT, 1, 0, 0, 0, 0, 0, 0],\n              [0, - self.EtaEM1, 0, 1, 0, 0, 0, 0],\n              [0, 0, 0, -self.EtaPM, 1, -self.EtaPM, 0, 0],\n              [0, 0, 1, 0,  - self.EtaEM2, 0, 0, 0],\n              [0, 0, - self.EtaGB, 0, 0, 0, 1, 0],\n              [0, 0, 0, 0, 0, 0, - self.EtaPPmodel(alt,vel,pwr), 1],\n              [phi, 0, 0, 0, 0, phi - 1, 0, 0],\n                      [0, 0, 0, 0, 0, 0, 0, 1]])\n\nb = np.array([0, 0, 0, 0, 0, 0, 0, 1])\n\nPowerRatio = np.linalg.solve(A,b)\n</code></pre>"},{"location":"user-guide/powertrain/#3-parallel-hybrid","title":"3. Parallel Hybrid","text":"<p>The system solves for the following power ratios:</p> <ul> <li>\\( \\displaystyle \\frac{P_f}{P_p} \\): fuel power to propulsive power  </li> <li>\\( \\displaystyle \\frac{P_{gt}}{P_p} \\): gas-turbine shaft power to propulsive power  </li> <li>\\( \\displaystyle \\frac{P_{gb}}{P_p} \\): gearbox output power to propulsive power  </li> <li>\\( \\displaystyle \\frac{P_{e1}}{P_p} \\): electric generator power to propulsive power  </li> <li>\\( \\displaystyle \\frac{P_{bat}}{P_p} \\): battery power to propulsive power  </li> <li>\\( \\displaystyle \\frac{P_{s1}}{P_p} \\): shaft power to propulsive power  </li> <li>\\( \\displaystyle \\frac{P_p}{P_p} = 1 \\): reference value</li> </ul> <p>with reference to the power chain in the image below:</p> <p></p> <p>The power flow is represented as:</p> \\[ A\\,x = b , \\] <p>where the matrix \\(A\\) is:</p> \\[ A = \\begin{bmatrix} -\\,\\eta_{GT}(h,V,P) &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; -\\,\\eta_{EM1} &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; -\\,\\eta_{PM} &amp; 1 &amp; -\\,\\eta_{PM} &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 &amp; -\\,\\eta_{EM2} &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; -\\,\\eta_{GB} &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; -\\,\\eta_{PP}(h,V,P) &amp; 1 \\\\ \\phi &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \\phi - 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\] \\[ b = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 1 \\end{bmatrix}. \\] <p>The solution vector \\(x\\) is:</p> \\[ x = \\begin{bmatrix} P_f/P_p \\\\ P_{gt}/P_p \\\\ P_{gb}/P_p \\\\ P_{e1}/P_p \\\\ P_{bat}/P_p \\\\ P_{s1}/P_p \\\\ P_p/P_p \\end{bmatrix}. \\] <p>The calculation is performed using the following code, that solves the linear system \\(A\\,x = b\\):</p> <pre><code>A = np.array([[- self.EtaGTmodel(alt,vel,pwr), 1, 0, 0, 0, 0, 0],\n              [0, -self.EtaGB, -self.EtaGB, 1, 0, 0, 0],\n              [0, 0, 0, 0, 1, -self.EtaPM, 0],\n              [0, 0, 1, 0, - self.EtaEM, 0, 0],\n              [0, 0, 0, - self.EtaPPmodel(alt,vel,pwr), 0, 0, 1],\n              [phi, 0, 0, 0, 0, phi - 1, 0],\n              [0, 0, 0, 0, 0, 0, 1]])\n\nb = np.array([0, 0, 0, 0, 0, 0, 1])\n\nPowerRatio = np.linalg.solve(A,b)\n</code></pre>"},{"location":"user-guide/powertrain/#engine-power-lapse-with-altitude","title":"Engine Power Lapse With Altitude","text":"<p>The constraint analysis requires a preliminary estimation of the engine power at different altitudes. Thermal engine maximum power decreases with altitude due to reduced air density.</p> <p>The power lapse ratio is:</p> \\[ \\alpha(h) = \\left(\\frac{\\rho(h)}{\\rho(0)}\\right)^n \\] <p>where \\(n=0.75\\) is the power lapse exponent. In the code:</p> <pre><code>def PowerLapse(self,altitude,DISA):\n        \"\"\" Full throttle power lapse, to be used in constraint analysis. Source: Ruijgrok, Elements of airplane performance, Eq.(6.7-11)\"\"\"\n        n = 0.75\n        lapse = (ISA.atmosphere.RHOstd(altitude,DISA)/ISA.atmosphere.RHOstd(0.0,DISA))**n\n        return lapse\n</code></pre>"},{"location":"user-guide/powertrain/#references","title":"References","text":"<p>de Vries, R., Brown, M., &amp; Vos, R. (2019). Preliminary Sizing Method for Hybrid-Electric Distributed-Propulsion Aircraft. Journal of Aircraft: devoted to aeronautical science and technology, 56(6), 2172-2188.</p>"},{"location":"user-guide/weight/","title":"Weight Module","text":"<p>The Weight module in PhlyGreen computes the aircraft\u2019s takeoff weight (WTO) through an iterative process that exploits the mission simulation workflow. The iterative process is necessary because the  mission simulation workflow requires the takeoff weight as input, which is unknown a priori.  It supports two fidelity levels:</p> <ul> <li>Class I \u2013 simplified empirical structural weight model  </li> <li>Class II \u2013 detailed FLOPS-based component weight estimation  </li> </ul>"},{"location":"user-guide/weight/#1-overview-of-the-weight-estimation-process","title":"1. Overview of the Weight Estimation Process","text":"<p>PhlyGreen solves for the takeoff weight that satisfies the aircraft mass balance:</p> \\[ W_{\\text{TO}}^{(i+1)} =  W_{\\text{payload}} + W_{\\text{crew}} + W_{\\text{structure}}(W_{\\text{TO}}^{(i)}) + W_{\\text{powertrain}}(W_{\\text{TO}}^{(i)}) + W_{\\text{fuel}}(W_{\\text{TO}}^{(i)}) + W_{\\text{battery}}(W_{\\text{TO}}^{(i)}) + W_{\\text{reserve}} \\] <p>where it is evident that the fuel, battery, structure, and powertrain masses depend on the takeoff weight.  More specifically, fuel and battery masses are solved for in the mission workflow, while the structure and powertrain masses are computed afterwards in the weight workflow.</p> <p>This is rewritten into a root-finding function:</p> \\[ f(W_{\\text{TO}}) = W_{\\text{payload}} + W_{\\text{crew}} + W_{\\text{structure}} + W_{\\text{PT}} + W_{\\text{fuel}} + W_{\\text{battery}} + W_{\\text{reserve}} - W_{\\text{TO}} \\] <p>The algorithm finds \\( W_{\\text{TO}}^{\\star} \\) such that:</p> \\[ f(W_{\\text{TO}}^{\\star}) = 0 \\] <p>using the Brent root-finding method. Each iteration, thus, requires the evaluation of the mission workflow.</p>"},{"location":"user-guide/weight/#2-weight-breakdown-components","title":"2. Weight Breakdown Components","text":"<p>PhlyGreen aggregates all mass contributions:</p> Component Traditional Hybrid Fuel weight \u2713 \u2713 Battery weight \u2717 \u2713 Structural weight \u2713 \u2713 Powertrain weight \u2713 \u2713 thermal + electric Payload + crew \u2713 \u2713 <p>Each component is recomputed at every iteration of WTO, except for the payload and crew, which are given as input requirements by the user.</p>"},{"location":"user-guide/weight/#3-fuel-weight-from-mission-energy","title":"3. Fuel Weight from Mission Energy","text":"<p>The Mission module returns the energy required, in [J], depending on the aircraft configuration:</p> <ul> <li>Traditional:</li> </ul> <pre><code>  E_f = mission.EvaluateMission(WTO)\n</code></pre> <ul> <li>Hybrid:</li> </ul> <pre><code>  (E_f, E_bat) = mission.EvaluateMission(WTO)\n</code></pre> <p>The fuel mass is computed as:</p> \\[ W_f = \\frac{E_f}{e_f} \\] <p>with \\( e_f \\) the fuel LHV [J/kg].</p> <p>If user does not specify a final reserve:</p> \\[ W_{\\text{reserve}} = 0.05\\, W_f \\]"},{"location":"user-guide/weight/#4-battery-weight-in-hybrid-configurations","title":"4. Battery Weight in Hybrid Configurations","text":"<p>The battery mass computation differs between Class I and Class II models:</p> <ul> <li>Class I: Battery mass must satisfy both energy and peak power requirements:</li> </ul> \\[ W_{\\text{bat}} = \\max\\left( \\frac{E_{\\text{bat}}/(1-\\text{SOC}_{\\min})}{e_{\\text{bat}}}, \\quad \\frac{P_{\\text{peak}}}{p_{\\text{bat}}} \\right) \\] <p>where:</p> <ul> <li>\\( e_{\\text{bat}} \\): battery specific energy [Wh/kg] </li> <li>\\( p_{\\text{bat}} \\): battery specific power [W/kg]  </li> <li>\\( P_{\\text{peak}} \\): maximum electrical power demanded [W], stored in <code>mission.Max_PBat</code> by the mission module. </li> </ul> <p>The code stores which term dominates (<code>WBatidx</code>).</p> <ul> <li>Class II: Battery mass is computed by the battery sizing loop in the mission module and accessed via the <code>battery.pack_weight</code> attribute.</li> </ul>"},{"location":"user-guide/weight/#5-powertrain-weight","title":"5. Powertrain Weight","text":"<p>For both traditional and hybrid aircraft, powertrain mass scales with subsystem specific powers, hence it is a Class I estimation:</p> \\[ W_{\\text{PT}} = \\frac{P_{\\text{thermal,max}}}{SP_{\\text{thermal}}} + \\frac{P_{\\text{electric,max}}}{SP_{\\text{electric}}} \\]"},{"location":"user-guide/weight/#6-structural-weight-models","title":"6. Structural Weight Models","text":""},{"location":"user-guide/weight/#61-class-i-model","title":"6.1 Class I Model","text":"<p>The structural mass is computed with semi-empirical functions of the takeoff mass. </p> \\[ W_{\\text{structure}} = f(W_{\\text{TO}}) \\] <p>The function is accessed via the <code>structures.StructuralWeight(WTO)</code> method.</p> <p>Class I is fast and used for conceptual studies.</p>"},{"location":"user-guide/weight/#62-class-ii-model-flops-implementation","title":"6.2 Class II Model \u2014 FLOPS Implementation","text":"<p>If <code>Class == \"II\"</code>, the code uses FLOPS_model.py, which estimates the masses of:</p> <ul> <li>Wing  </li> <li>Fuselage  </li> <li>Horizontal / vertical tail  </li> <li>Landing gear  </li> <li>Nacelle assemblies  </li> <li>Propellers  </li> <li>Systems and equipment  </li> <li>Paint  </li> </ul> <p>The FLOPS component masses (in lb) are summed and converted to kg:</p> \\[ W_{\\text{structure}} = \\sum_i W_{i,\\text{FLOPS}} \\] <p>This model captures:</p> <ul> <li>aerodynamic load scaling  </li> <li>geometric effects  </li> <li>structural layout assumptions  </li> </ul>"},{"location":"user-guide/weight/#7-brent-root-finding-loop","title":"7. Brent Root-Finding Loop","text":"<p>PhlyGreen solves:</p> \\[ f(W_{\\text{TO}}) = 0 \\] <p>with:</p> <pre><code>self.WTO = brenth(func, WTO_min, WTO_max, xtol=0.1)\n</code></pre> <p>The function returns:</p> <pre><code>W_total - WTO\n</code></pre>"}]}