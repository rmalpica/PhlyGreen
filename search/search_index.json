{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"PhlyGreen","text":"<p>PhlyGreen is an open-source platform for aircraft designed, focused on novel propulsion architectures, supporting hybrid-electric, all-electric, and conventional configurations.  The code is under development at Sapienza Universita' di Roma. </p> <p>This guide explains the logic, workflow, and structure of each major subsystem in the codebase.</p> <p>This documentation includes:</p> <ul> <li>User Guide \u2013 learn how to run and customize missions and designs </li> <li>Developer Guide \u2013 understand the architecture and modify modules  </li> <li>API Reference \u2013 automatically generated from Python docstrings  </li> </ul> <p>This manual is designed to help both students and researchers understand how PhlyGreen works internally and how to extend it for new propulsion concepts.</p> <p>PhlyGreen has been created by Riccardo Malpica Galassi and Matteo Blandino (Sapienza University of Rome). The project has also benefited from contributions by Aeronautical Engineering Master\u2019s students, including Jo\u00e3o Delille and Valeria Falcone, as part of their thesis research.</p> <p>How to cite: M. Blandino, P. P. Ciottoli, M. M. Molinari, J. Liberatori, R. Malpica Galassi, Uncertainty Propagation of Optimal Hybrid-Electric Aircraft Designs in a Scenario-Based Framework, Journal of Aircraft (2025).</p> <p>This work is part of the research activity developed by the authors within the framework of the \u201cPNRR\u201d CN4 MOST (Mobilit\u00e0 sostenibile): SPOKE 1 (Air Mobility), WP5: \u201cMultidisciplinary design optimization and innovative solutions for next generation green aircraft with demonstrator\u201d.</p>"},{"location":"api/battery/","title":"Battery API Reference","text":""},{"location":"api/battery/#PhlyGreen.Systems.Battery.Battery.Battery","title":"Battery","text":"<pre><code>Battery(aircraft)\n</code></pre> <p>Battery electro-thermal model with safety checks.</p> <p>Handles: - Voltage model evaluated at cell level - SOC tracking through current integration - Max current enforcement - Pack configuration (series/parallel) - Thermal dynamics</p> Source code in <code>trunk/PhlyGreen/Systems/Battery/Battery.py</code> <pre><code>def __init__(self, aircraft):\n    self.aircraft = aircraft\n\n    self.pack_Vmax = 800\n    self._SOC_min = None\n    self._it = 0         # integral of current [Ah], used to compute SOC\n    self._i = None       # pack current [A]\n    self._T = None       # cell temperature [K]\n    self._cell_max_current = None\n    self.mdot = 0        # cooling mass flow estimate from heat loss model\n</code></pre>"},{"location":"api/battery/#PhlyGreen.Systems.Battery.Battery.Battery.E0","title":"E0  <code>property</code>","text":"<pre><code>E0\n</code></pre> <p>Voltage constant</p>"},{"location":"api/battery/#PhlyGreen.Systems.Battery.Battery.Battery.K","title":"K  <code>property</code>","text":"<pre><code>K\n</code></pre> <p>Polarization resistance (Arrhenius temperature correction)</p>"},{"location":"api/battery/#PhlyGreen.Systems.Battery.Battery.Battery.Q","title":"Q  <code>property</code>","text":"<pre><code>Q\n</code></pre> <p>Nominal capacity</p>"},{"location":"api/battery/#PhlyGreen.Systems.Battery.Battery.Battery.R","title":"R  <code>property</code>","text":"<pre><code>R\n</code></pre> <p>Internal ohmic resistance (Arrhenius temperature correction)</p>"},{"location":"api/battery/#PhlyGreen.Systems.Battery.Battery.Battery.SOC","title":"SOC  <code>property</code>","text":"<pre><code>SOC\n</code></pre> <p>Real-time State-Of-Charge computed from integrated current.</p>"},{"location":"api/battery/#PhlyGreen.Systems.Battery.Battery.Battery.SOC_min","title":"SOC_min  <code>property</code> <code>writable</code>","text":"<pre><code>SOC_min\n</code></pre> <p>Ensures SOC_min is between 0 and 1.</p>"},{"location":"api/battery/#PhlyGreen.Systems.Battery.Battery.Battery.Voc","title":"Voc  <code>property</code>","text":"<pre><code>Voc\n</code></pre> <p>Open-circuit pack voltage.</p>"},{"location":"api/battery/#PhlyGreen.Systems.Battery.Battery.Battery.Vout","title":"Vout  <code>property</code>","text":"<pre><code>Vout\n</code></pre> <p>Pack-level voltage from series connection.</p>"},{"location":"api/battery/#PhlyGreen.Systems.Battery.Battery.Battery.cell_Voc","title":"cell_Voc  <code>property</code>","text":"<pre><code>cell_Voc\n</code></pre> <p>Open-circuit voltage at the current SOC.</p>"},{"location":"api/battery/#PhlyGreen.Systems.Battery.Battery.Battery.cell_Vout","title":"cell_Vout  <code>property</code>","text":"<pre><code>cell_Vout\n</code></pre> <p>Actual instantaneous cell voltage. Should never drop below the minimum safe voltage.</p>"},{"location":"api/battery/#PhlyGreen.Systems.Battery.Battery.Battery.cell_i","title":"cell_i  <code>property</code>","text":"<pre><code>cell_i\n</code></pre> <p>Cell-level current (A). For parallel strings, each cell sees pack current divided by P.</p>"},{"location":"api/battery/#PhlyGreen.Systems.Battery.Battery.Battery.cell_it","title":"cell_it  <code>property</code>","text":"<pre><code>cell_it\n</code></pre> <p>Discharge per cell (Ah).</p>"},{"location":"api/battery/#PhlyGreen.Systems.Battery.Battery.Battery.Configure","title":"Configure","text":"<pre><code>Configure(parallel_cells)\n</code></pre> <p>Defines the parallel count (P_number) and computes pack-level properties: mass, volume, max power, nominal energy.</p>"},{"location":"api/battery/#PhlyGreen.Systems.Battery.Battery.Battery.Configure--parameters","title":"Parameters","text":"<p>parallel_cells : int     Number of cells in parallel (P_number).</p> Source code in <code>trunk/PhlyGreen/Systems/Battery/Battery.py</code> <pre><code>def Configure(self, parallel_cells):\n    \"\"\"\n    Defines the parallel count (P_number) and computes\n    pack-level properties: mass, volume, max power, nominal energy.\n\n    Parameters\n    ----------\n    parallel_cells : int\n        Number of cells in parallel (P_number).\n\n    \"\"\"\n    self.P_number = parallel_cells\n    self.cells_total = self.P_number * self.S_number\n\n    # physical characteristics of the whole pack:\n    stack_length = self.cell_radius * np.ceil(self.S_number / 2)\n    # stack_width = self.cell_radius * (2 + np.sqrt(3))\n    stack_width = self.cell_radius * 2\n    self.pack_volume = self.cell_height * stack_width * stack_length\n    self.pack_weight = self.cell_mass * self.cells_total\n    if self.pack_weight &gt; 3000000000000000:\n        raise BatteryError(\"OVERWEIGHT! SOMETHING IS VERY WRONG BECAUSE BATTERY IS NOT CONVERGING\")\n    # nominal pack values\n    self.pack_energy = self.cell_energy_nom * self.cells_total\n    self.pack_power_max = (\n        self.cell_max_current * self._voltageModel(0, self.cell_max_current) * self.cells_total\n    )\n    self.pack_charge = self.cell_capacity * self.P_number\n</code></pre>"},{"location":"api/battery/#PhlyGreen.Systems.Battery.Battery.Battery.Power_2_current","title":"Power_2_current","text":"<pre><code>Power_2_current(P)\n</code></pre> <p>Calculates the current output from the battery. The calculations are for a single     cell, as that is what the model is made for. The output is the current for the entire     battery pack however. The power is simply divided by the total number of cells, as     every cell delivers equal power regardless of the configuration of the battery. Receives:     P - power demanded from the battery Returns:     I_out - current output from the battery</p> Source code in <code>trunk/PhlyGreen/Systems/Battery/Battery.py</code> <pre><code>def Power_2_current(self, P):\n    \"\"\"Calculates the current output from the battery. The calculations are for a single\n        cell, as that is what the model is made for. The output is the current for the entire\n        battery pack however. The power is simply divided by the total number of cells, as\n        every cell delivers equal power regardless of the configuration of the battery.\n    Receives:\n        P - power demanded from the battery\n    Returns:\n        I_out - current output from the battery\n    \"\"\"\n\n    if P == 0:  # skips all the math if power is zero\n        return 0\n\n    # V = E0 - I*R - I*K*(Q/(Q-it)) - it*K*(Q/(Q-it)) + A*exp(-B * it)\n    # V = E0 - I*R - I*Qr - it*Qr + ee &lt;- with substitutions to make shorter\n    # P = V*I = E0*I - I^2*R - I^2*Qr - I*it*Qr + I*ee \n    # P = I^2 *(-R-Qr) + I *(E0+ee-it*Qr)\n    # quadratic solve: \n    # a*I^2 + b*I - P = 0\n\n    E0, R, K, Q = self.E0, self.R, self.K, self.Q\n    A, B = self.exp_amplitude, self.exp_time_ctt\n    it = self.cell_it\n    P = P / self.cells_total  # all cells deliver the same power\n\n    Qr = K * Q / (Q - it)\n    ee = A * np.exp(-B * it)\n    a = -R - Qr\n    b = E0 + ee - it * Qr\n    c = -P\n    Disc = b**2 - 4 * a * c  # quadratic formula discriminant\n\n    if Disc &lt; 0:\n        I_out = None\n        return I_out\n\n    else:\n        I_out = (-b + np.sqrt(Disc)) / (2 * a)  # just the quadratic formula\n\n    return I_out * self.P_number\n</code></pre>"},{"location":"api/battery/#PhlyGreen.Systems.Battery.Battery.Battery.SetInput","title":"SetInput","text":"<pre><code>SetInput()\n</code></pre> <p>This grabs the CellModel object from the aircraft class where a dictionary defines some inputs set by the user. Then according to the inputs it defines the battery model to use. The constants come from the cell_models.py module and are modified according to the user input.</p> Source code in <code>trunk/PhlyGreen/Systems/Battery/Battery.py</code> <pre><code>def SetInput(self):\n    \"\"\"\n    This grabs the CellModel object from the aircraft class where a\n    dictionary defines some inputs set by the user.\n    Then according to the inputs it defines the battery model to use.\n    The constants come from the cell_models.py module and are modified\n    according to the user input.\n    \"\"\"\n\n    bat_inputs = self.aircraft.CellInput\n            #\u00a0set the battery model class\n    self.BatteryClass = bat_inputs['Class']\n\n\n    if self.BatteryClass == 'II':\n        self.SOC_min = bat_inputs['Minimum SOC']\n        self.aircraft.mission.startT = bat_inputs['Initial temperature'] \n        self.aircraft.mission.T_battery_limit = bat_inputs['Max operative temperature'] \n\n    if self.BatteryClass == 'I':\n        self.Ebat = bat_inputs['SpecificEnergy']*3600\n        self.pbat = bat_inputs['SpecificPower']\n        self.SOC_min = bat_inputs['Minimum SOC'] \n        return\n\n    if self.BatteryClass != 'II':\n        raise Exception(f\"Unrecognized model class: {self.BatteryClass}\")\n\n    if bat_inputs['Model'] is None: # Fallback to a default model if none is given\n        model = 'Finger-Cell-Thermal'\n    else:\n        model = bat_inputs['Model']\n\n\n\n    # Get all the cell parameters\n    cell = Cell_Models[model]\n    self.Tref              = cell['Reference Temperature']     # in kelvin\n    self.T = self.Tref\n    self.exp_amplitude     = cell['Exp Amplitude']                  # in volts\n    self.exp_time_ctt      = cell['Exp Time constant']              # in Ah^-1 \n    self.cell_resistance   = cell['Internal Resistance']            # in ohms\n    self.R_arrhenius       = cell['Resistance Arrhenius Constant']  # dimensionless\n    self.polarization_ctt  = cell['Polarization Constant']          # in Volts over amp hour\n    self.K_arrhenius       = cell['Polarization Arrhenius Constant']# dimensionless\n    self.cell_capacity     = cell['Cell Capacity']                  # in Ah\n    self.Q_slope           = cell['Capacity Thermal Slope']         # in Ah per kelvin\n    self.voltage_ctt       = cell['Voltage Constant']               # in volts\n    self.E_slope           = cell['Voltage Thermal Slope']          # in volts per kelvin\n    self.cell_Vmax         = self.exp_amplitude + self.voltage_ctt  # in volts\n    self.cell_Vmin         = cell['Cell Voltage Min']               # in volts\n    self.cell_max_current  = cell['Cell Current Max']                  # dimensionless\n    self.cell_mass         = cell['Cell Mass']                      # in kg\n    self.cell_radius       = cell['Cell Radius']                    # in m\n    self.cell_height       = cell['Cell Height']                    # in m\n    self.Vnom              = cell['Cell Voltage Nominal']  # in volts\n    self.cell_energy_nom   = self.Vnom * self.cell_capacity\n\n    # Verify that the voltages are correctly set\n    if not (self.cell_Vmax &gt; self.cell_Vmin):\n        raise ValueError(\n            \"Fail_Condition_11\\nIllegal cell voltages: Vmax must be greater than Vmin\"\n        )\n\n    # Modify the cell according to the user specified energy and power densities\n    # Modify the capacity of the cell\n    if bat_inputs[\"SpecificEnergy\"] is not None:\n        ecell = bat_inputs[\"SpecificEnergy\"] * self.cell_mass   # cell energy in Wh\n        capcell = ecell / self.Vnom                             # cell charge in Ah\n        eratio = capcell / self.cell_capacity # ratio between model charge and new charge\n        #print(f\"old{self.cell_capacity}    new{capcell}\")\n\n        self.cell_capacity = capcell\n        self.cell_energy_nom = ecell\n        self.Q_slope *= eratio  # the slope is a fraction of the capacity, so it scales with the ratio of capacities\n        self.exp_time_ctt /= eratio  # divides by the ratio because its the INVERSE of the exponential zone charge\n\n        # Scale the specific power accordingly, unless a fixed one is requested\n        if bat_inputs[\"SpecificPower\"] is None:\n            self.polarization_ctt /= eratio\n            self.K_arrhenius /= eratio\n            self.cell_resistance /= eratio\n            self.R_arrhenius /= eratio\n            self.cell_max_current *= eratio\n\n        # implement this properly later if needed\n        # make the specific power a ratio of the specific energy\n        # to be able to pick a certain C rating\n        # if bat_inputs[\"SpecificPower\"] is None:\n        #     pcell = 4 * bat_inputs[\"SpecificEnergy\"] * self.cell_mass  # cell power in W\n        #     pcellnow = self.cell_max_current * self._voltageModel(0, self.cell_max_current)\n        #     pratio = pcell / pcellnow\n\n        #     self.polarization_ctt /= pratio\n        #     self.K_arrhenius /= pratio\n        #     self.cell_resistance /= pratio\n        #     self.R_arrhenius /= pratio\n        #     self.cell_max_current *= pratio\n\n\n    # Modify the internal resistance and current limit to adjust power\n    if bat_inputs[\"SpecificPower\"] is not None:\n        pcell = bat_inputs[\"SpecificPower\"] * self.cell_mass  # cell power in W\n        pcellnow = self.cell_max_current * self._voltageModel(0, self.cell_max_current)\n        pratio = pcell / pcellnow\n        #print(f\"Current ratio:{pratio}\")\n        #print(f\"peak power old:{pcellnow}\")\n\n        # Dividing the internal resistance by a ratio increases\n        # the maximum deliverable power by the same ratio\n        self.polarization_ctt /= pratio\n        self.K_arrhenius /= pratio\n        self.cell_resistance /= pratio\n        self.R_arrhenius /= pratio\n\n        # Note: the cell max current needs to be the last thing\n        # to be calculated because its setter verifies its\n        # validity against the cell properties\n        self.cell_max_current *= pratio\n    # print(f\"peak power new:{self.cell_max_current*self._voltageModel(0, self.cell_max_current)}\")\n\n\n    # Number of cells in series to achieve desired voltage.\n    # Higher voltage is preferred as it minimizes losses\n    # due to lower current being needed.\n    if bat_inputs[\"Pack Voltage\"] is not None:\n        self.pack_Vmax = bat_inputs[\"Pack Voltage\"]\n    else:\n        self.pack_Vmax = 740\n    self.S_number = np.floor(self.pack_Vmax / self.cell_Vmax)\n\n    self.cell_area_surface = 2*np.pi*self.cell_radius*self.cell_height\n    self.module_area_section = (2*self.cell_radius)**2-np.pi*self.cell_radius**2\n\n    self.Rith = 3.3*(self.cell_radius/0.022)**2 # probably need a citation for this one\n    self.Cth = 1000 * self.cell_mass\n</code></pre>"},{"location":"api/battery/#PhlyGreen.Systems.Battery.Battery.Battery.heatLoss","title":"heatLoss","text":"<pre><code>heatLoss(Ta, rho)\n</code></pre> <p>Simple differential equation describing a     simplified lumped element thermal model of the cells Receives:     - Ta   - temperature of the ambient cooling air     - rho  - density of the ambient air Returns:     - dTdt - battery temperature derivative     - P    - dissipated waste power per cell</p> Source code in <code>trunk/PhlyGreen/Systems/Battery/Battery.py</code> <pre><code>def heatLoss(self, Ta, rho):\n    \"\"\" Simple differential equation describing a\n        simplified lumped element thermal model of the cells\n    Receives:\n        - Ta   - temperature of the ambient cooling air\n        - rho  - density of the ambient air\n    Returns:\n        - dTdt - battery temperature derivative\n        - P    - dissipated waste power per cell\n    \"\"\"\n    Ta = max(Ta,273.15)\n    # print('T ambient: ', Ta)\n\n    V, Voc = self.cell_Vout, self.cell_Voc\n    i = self.cell_i\n    T, dEdT = self.T, self.E_slope\n    # print('Battery temperature: ', T-273.15)\n    Rith = self.Rith\n    Cth = self.Cth\n    P = (Voc - V) * i + dEdT * i * T\n    self.mdot = 0.0001*P\n    # if P&lt;0:\n    #     self.mdot = 0\n    h = max(\n        (  # taken from http://dx.doi.org/10.1016/j.jpowsour.2013.10.052\n            30* ( ((self.mdot) / (self.module_area_section * rho)) / 5) ** 0.8\n        ),\n        2)\n\n    if (self.phi &gt; 0.) &amp; (T &lt; 273.15 + self.aircraft.mission.T_battery_limit):\n        h = 0.            \n\n\n    # print(self.mdot)\n\n    if h == 0:  # avoid division by 0\n        dTdt = P / Cth\n    else:\n        Rth = 1 / (h * self.cell_area_surface) + Rith\n        dTdt = P / Cth + (Ta - T) / (Rth * Cth)\n    # print(f\"h: {h}   R:{Rth}     surface:{self.cell_area_surface}    crosssec:{self.module_area_section}\")\n    return dTdt, P\n</code></pre>"},{"location":"api/battery/#PhlyGreen.Systems.Battery.Battery.BatteryError","title":"BatteryError","text":"<pre><code>BatteryError(message, code=None)\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Custom exception to be caught when the battery violates physical or model constraints.</p> Source code in <code>trunk/PhlyGreen/Systems/Battery/Battery.py</code> <pre><code>def __init__(self, message, code=None):\n    super().__init__(message)\n    self.code = code\n</code></pre>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>This page explains how to install PhlyGreen, its dependencies, and the recommended development environment. The goal is to provide a clean, reproducible setup that works for both users and contributors.</p> <p>The recommended setup uses Conda to isolate dependencies and ensure consistent behavior across systems.</p>"},{"location":"getting-started/installation/#1-install-conda-if-not-already-installed","title":"1. Install Conda (if not already installed)","text":"<p>If you do not already have Conda or Miniconda, install one of the following:</p> <ul> <li>Miniconda: https://docs.conda.io/en/latest/miniconda.html </li> <li>Anaconda: https://www.anaconda.com/products/distribution</li> </ul> <p>Verify installation:</p> <pre><code>conda --version\n</code></pre>"},{"location":"getting-started/installation/#2-create-the-conda-environment","title":"2. Create the Conda Environment","text":"<p>PhlyGreen is tested with Python 3.12, so create a dedicated environment:</p> <pre><code>conda create -n phlygreen python=3.12\n</code></pre> <p>Activate it:</p> <pre><code>conda activate phlygreen\n</code></pre>"},{"location":"getting-started/installation/#3-clone-the-repository","title":"3. Clone the Repository","text":"<pre><code>git clone https://github.com/rmalpica/PhlyGreen.git\ncd PhlyGreen\n</code></pre> <p>Be aware that the repository is still private: you need the admin approval first.</p>"},{"location":"getting-started/installation/#4-install-python-dependencies","title":"4. Install Python Dependencies","text":"<p>Install required dependencies:</p> <pre><code>pip install -r requirements.txt\n</code></pre>"},{"location":"getting-started/installation/#5-install-phlygreen-editable-mode-recommended","title":"5. Install PhlyGreen (Editable Mode Recommended)","text":"<p>Install in development / editable mode:</p> <pre><code>cd PhlyGreen/trunk\npip install -e .\n</code></pre> <p>Why -e?</p> <ul> <li>Links the package to your local directory</li> <li>Any code change is immediately reflected</li> <li>No need to reinstall after editing or pulling updates</li> <li>Recommended for research and development</li> </ul> <p>For a standard installation instead:</p> <pre><code>cd PhlyGreen/trunk\npip install .\n</code></pre>"},{"location":"getting-started/installation/#6-verify-the-installation","title":"6. Verify the Installation","text":"<pre><code>python -c \"import PhlyGreen; print('PhlyGreen version:', PhlyGreen.__version__)\"\n</code></pre>"},{"location":"getting-started/installation/#7-update-your-local-copy-when-updates-are-available-in-the-repository","title":"7. Update your local copy when updates are available in the repository","text":"<pre><code>git pull\n</code></pre>"},{"location":"getting-started/logic/","title":"Program Logic","text":""},{"location":"getting-started/logic/#phlygreen-workflow","title":"PhlyGreen workflow","text":"<p><code>PhlyGreen</code> begins from a set of user-defined aircraft constraints, design targets, and a mission profile that the aircraft must be capable of completing. Together, these inputs define the configuration of the simulation. The objective of <code>PhlyGreen</code> is to determine the required size and mass of each major aircraft subsystem so that the vehicle can successfully fly the prescribed mission while respecting all aerodynamic, structural, propulsion, and energy constraints.</p> <p>To accomplish this, PhlyGreen is organized into a set of specialized modules\u2014Constraints, Mission, Performance, Powertrain, Aerodynamics, Structures, Weight, Battery, Well-to-Wake, and ClimateImpact\u2014each responsible for computing the properties of a specific subsystem. For any candidate aircraft design, these modules evaluate performance, energy use, or mass under the specified mission conditions.</p> <p></p>"},{"location":"getting-started/logic/#iterative-weight-convergence-loop","title":"Iterative Weight-Convergence Loop","text":"<p>A key feature of PhlyGreen is its iterative sizing process, centered on the aircraft's takeoff weight (WTO). Because component masses depend on the mission performance, and mission performance depends on the aircraft mass, the system is inherently coupled.</p> <p>PhlyGreen resolves this coupling using a root-finding loop: - Assume a trial takeoff weight (WTO). - Simulate the mission and size all components consistently with that assumed WTO. - Sum the resulting component masses to compute a new, \u201coutput\u201d WTO. - Compare input and output WTO values. - Repeat, adjusting the trial WTO until the two match within a user-defined tolerance.</p> <p>This loop is solved efficiently using Brent\u2019s method, a robust hybrid root-finding algorithm. Its numerical details lie beyond the scope of this documentation, but it ensures rapid and stable convergence for all supported aircraft configurations.</p> <p></p>"},{"location":"getting-started/logic/#role-of-mission-and-weight-modules","title":"Role of Mission and Weight Modules","text":"<p>The Mission module evaluates the aircraft\u2019s performance over the full mission profile. For each flight segment, it computes:</p> <ul> <li>Aerodynamic forces</li> <li>Propulsion power demand</li> <li>Fuel flow or electric power consumption</li> <li>Battery current, SOC, and temperature evolution</li> <li>Hybrid power split (if applicable)</li> </ul> <p>The Weight module then uses these mission results to compute:</p> <ul> <li>Fuel mass required to complete the mission</li> <li>Battery mass (energy- or power-constrained)</li> <li>Propulsion system mass</li> <li>Structural mass (Class I or Class II via FLOPS)</li> <li>Additional fixed payload or crew masses</li> </ul> <p>These quantities are aggregated into a total estimated takeoff weight, which becomes the output of the sizing loop.</p>"},{"location":"getting-started/logic/#energy-estimation-and-component-sizing","title":"Energy Estimation and Component Sizing","text":"<p>A central element of the workflow is the energy estimation, especially important for hybrid-electric aircraft. Over each flight segment, PhlyGreen integrates:</p> <ul> <li>Fuel power \u2192 fuel energy use</li> <li>Electrical power \u2192 battery energy use</li> <li>Peak power \u2192 power constraints on the electric system</li> </ul> <p>At the end of the mission, the energy totals are used to determine:</p> <ul> <li>fuel mass: \\(W_{fuel}=\\frac{E_{fuel}}{LHV}\\)</li> <li>battery mass, from \\(E_{bat}\\) and \\(P_{bat,peak}\\) depending on the battery model</li> </ul>"},{"location":"getting-started/running-your-first-mission/","title":"PhlyGreen Tutorial: sizing a parallel-hybrid aircraft","text":"<p>Import packages</p> In\u00a0[1]: Copied! <pre>import sys\nsys.path.insert(0,'../')\nimport PhlyGreen as pg\nimport numpy as np\nimport matplotlib.pyplot as plt\n</pre> import sys sys.path.insert(0,'../') import PhlyGreen as pg import numpy as np import matplotlib.pyplot as plt <p>Create instances of subsystems. Each one of those requires an Aircraft object as argument. By passing (None) as argument, we are creating empty objects (for the moment).</p> In\u00a0[2]: Copied! <pre>powertrain = pg.Systems.Powertrain.Powertrain(None)\nstructures = pg.Systems.Structures.Structures(None)\naerodynamics = pg.Systems.Aerodynamics.Aerodynamics(None)\nperformance = pg.Performance.Performance(None)\nmission = pg.Mission.Mission(None)\nweight = pg.Weight.Weight(None)\nconstraint = pg.Constraint.Constraint(None)\nwelltowake = pg.WellToWake.WellToWake(None)\nbattery = pg.Systems.Battery.Battery(None)\nclimateimpact = pg.ClimateImpact.ClimateImpact(None)\n</pre> powertrain = pg.Systems.Powertrain.Powertrain(None) structures = pg.Systems.Structures.Structures(None) aerodynamics = pg.Systems.Aerodynamics.Aerodynamics(None) performance = pg.Performance.Performance(None) mission = pg.Mission.Mission(None) weight = pg.Weight.Weight(None) constraint = pg.Constraint.Constraint(None) welltowake = pg.WellToWake.WellToWake(None) battery = pg.Systems.Battery.Battery(None) climateimpact = pg.ClimateImpact.ClimateImpact(None) <p>Create instance of Aircraft object.</p> In\u00a0[3]: Copied! <pre>myaircraft = pg.Aircraft(powertrain, structures, aerodynamics, performance, mission, weight, constraint, welltowake, battery, climateimpact)\n</pre> myaircraft = pg.Aircraft(powertrain, structures, aerodynamics, performance, mission, weight, constraint, welltowake, battery, climateimpact) <p>Create the connections with its subsystems.</p> In\u00a0[4]: Copied! <pre>powertrain.aircraft = myaircraft\nstructures.aircraft = myaircraft\naerodynamics.aircraft = myaircraft\nmission.aircraft = myaircraft\nperformance.aircraft = myaircraft\nweight.aircraft = myaircraft\nconstraint.aircraft = myaircraft\nwelltowake.aircraft = myaircraft\nbattery.aircraft = myaircraft\nclimateimpact.aircraft = myaircraft\n</pre> powertrain.aircraft = myaircraft structures.aircraft = myaircraft aerodynamics.aircraft = myaircraft mission.aircraft = myaircraft performance.aircraft = myaircraft weight.aircraft = myaircraft constraint.aircraft = myaircraft welltowake.aircraft = myaircraft battery.aircraft = myaircraft climateimpact.aircraft = myaircraft <p>Define input dictionaries</p> In\u00a0[5]: Copied! <pre>ConstraintsInput = {'DISA': 0.,\n                    'Cruise': {'Speed': 0.5, 'Speed Type':'Mach', 'Beta': 0.95, 'Altitude': 8000.},\n                    'AEO Climb': {'Speed': 210, 'Speed Type':'KCAS', 'Beta': 0.97, 'Altitude': 6000., 'ROC': 5},\n                    'OEI Climb': {'Speed': 1.2*34.5, 'Speed Type': 'TAS', 'Beta': 1., 'Altitude': 0., 'Climb Gradient': 0.021},\n                    'Take Off': {'Speed': 90, 'Speed Type': 'TAS', 'Beta': 1., 'Altitude': 100., 'kTO': 1.2, 'sTO': 950},\n                    'Landing':{'Speed': 59., 'Speed Type': 'TAS', 'Altitude': 500.},\n                    'Turn':{'Speed': 210, 'Speed Type': 'KCAS', 'Beta': 0.9, 'Altitude': 5000, 'Load Factor': 1.1},\n                    'Ceiling':{'Speed': 0.5, 'Beta': 0.8, 'Altitude': 9500, 'HT': 0.5},\n                    'Acceleration':{'Mach 1': 0.3, 'Mach 2':0.4, 'DT': 180, 'Altitude': 6000, 'Beta': 0.9}}\n</pre> ConstraintsInput = {'DISA': 0.,                     'Cruise': {'Speed': 0.5, 'Speed Type':'Mach', 'Beta': 0.95, 'Altitude': 8000.},                     'AEO Climb': {'Speed': 210, 'Speed Type':'KCAS', 'Beta': 0.97, 'Altitude': 6000., 'ROC': 5},                     'OEI Climb': {'Speed': 1.2*34.5, 'Speed Type': 'TAS', 'Beta': 1., 'Altitude': 0., 'Climb Gradient': 0.021},                     'Take Off': {'Speed': 90, 'Speed Type': 'TAS', 'Beta': 1., 'Altitude': 100., 'kTO': 1.2, 'sTO': 950},                     'Landing':{'Speed': 59., 'Speed Type': 'TAS', 'Altitude': 500.},                     'Turn':{'Speed': 210, 'Speed Type': 'KCAS', 'Beta': 0.9, 'Altitude': 5000, 'Load Factor': 1.1},                     'Ceiling':{'Speed': 0.5, 'Beta': 0.8, 'Altitude': 9500, 'HT': 0.5},                     'Acceleration':{'Mach 1': 0.3, 'Mach 2':0.4, 'DT': 180, 'Altitude': 6000, 'Beta': 0.9}} In\u00a0[\u00a0]: Copied! <pre>MissionInput = {'Range Mission': 750,  #nautical miles\n                'Range Diversion': 220,  #nautical miles\n                'Beta start': 0.97,\n                'Payload Weight': 4560,  # [kg]\n                'Crew Weight': 500}  # [kg]\n</pre> MissionInput = {'Range Mission': 750,  #nautical miles                 'Range Diversion': 220,  #nautical miles                 'Beta start': 0.97,                 'Payload Weight': 4560,  # [kg]                 'Crew Weight': 500}  # [kg] In\u00a0[7]: Copied! <pre>MissionStages = {'Takeoff': {'Supplied Power Ratio':{'phi': 0.}},\n                'Climb1': {'type': 'ConstantRateClimb', 'input': {'CB': 0.16, 'Speed': 77, 'StartAltitude': 100, 'EndAltitude': 1500}, 'Supplied Power Ratio':{'phi_start': 0, 'phi_end':0}},\n                 'Climb2': {'type': 'ConstantRateClimb', 'input': {'CB': 0.08, 'Speed': 120, 'StartAltitude': 1500, 'EndAltitude': 4500}, 'Supplied Power Ratio':{'phi_start': 0, 'phi_end':0 }},\n                 'Climb3': {'type': 'ConstantRateClimb', 'input': {'CB': 0.07, 'Speed': 125, 'StartAltitude': 4500, 'EndAltitude': 8000}, 'Supplied Power Ratio':{'phi_start': 0, 'phi_end':0 }},\n                 'Cruise': {'type': 'ConstantMachCruise', 'input':{ 'Mach': 0.4, 'Altitude': 8000}, 'Supplied Power Ratio':{'phi_start': 0, 'phi_end':0.5}},\n                 'Descent1': {'type': 'ConstantRateDescent', 'input':{'CB': -0.04, 'Speed': 90, 'StartAltitude': 8000, 'EndAltitude': 200}, 'Supplied Power Ratio':{'phi_start': 0.0, 'phi_end':0.0 }}}\n\nDiversionStages = {'Climb1': {'type': 'ConstantRateClimb', 'input': {'CB': 0.08, 'Speed': 110, 'StartAltitude': 200, 'EndAltitude': 3100}, 'Supplied Power Ratio':{'phi_start': 0.0, 'phi_end':0.0 }},\n                 'Cruise': {'type': 'ConstantMachCruise', 'input':{ 'Mach': 0.35, 'Altitude': 3100}, 'Supplied Power Ratio':{'phi_start': 0.0, 'phi_end':0.0}},\n                 'Descent1': {'type': 'ConstantRateDescent', 'input':{'CB': -0.04, 'Speed': 90, 'StartAltitude': 3100, 'EndAltitude': 200}, 'Supplied Power Ratio':{'phi_start': 0.0, 'phi_end':0.0 }}}\n</pre> MissionStages = {'Takeoff': {'Supplied Power Ratio':{'phi': 0.}},                 'Climb1': {'type': 'ConstantRateClimb', 'input': {'CB': 0.16, 'Speed': 77, 'StartAltitude': 100, 'EndAltitude': 1500}, 'Supplied Power Ratio':{'phi_start': 0, 'phi_end':0}},                  'Climb2': {'type': 'ConstantRateClimb', 'input': {'CB': 0.08, 'Speed': 120, 'StartAltitude': 1500, 'EndAltitude': 4500}, 'Supplied Power Ratio':{'phi_start': 0, 'phi_end':0 }},                  'Climb3': {'type': 'ConstantRateClimb', 'input': {'CB': 0.07, 'Speed': 125, 'StartAltitude': 4500, 'EndAltitude': 8000}, 'Supplied Power Ratio':{'phi_start': 0, 'phi_end':0 }},                  'Cruise': {'type': 'ConstantMachCruise', 'input':{ 'Mach': 0.4, 'Altitude': 8000}, 'Supplied Power Ratio':{'phi_start': 0, 'phi_end':0.5}},                  'Descent1': {'type': 'ConstantRateDescent', 'input':{'CB': -0.04, 'Speed': 90, 'StartAltitude': 8000, 'EndAltitude': 200}, 'Supplied Power Ratio':{'phi_start': 0.0, 'phi_end':0.0 }}}  DiversionStages = {'Climb1': {'type': 'ConstantRateClimb', 'input': {'CB': 0.08, 'Speed': 110, 'StartAltitude': 200, 'EndAltitude': 3100}, 'Supplied Power Ratio':{'phi_start': 0.0, 'phi_end':0.0 }},                  'Cruise': {'type': 'ConstantMachCruise', 'input':{ 'Mach': 0.35, 'Altitude': 3100}, 'Supplied Power Ratio':{'phi_start': 0.0, 'phi_end':0.0}},                  'Descent1': {'type': 'ConstantRateDescent', 'input':{'CB': -0.04, 'Speed': 90, 'StartAltitude': 3100, 'EndAltitude': 200}, 'Supplied Power Ratio':{'phi_start': 0.0, 'phi_end':0.0 }}}  In\u00a0[\u00a0]: Copied! <pre>EnergyInput = {'Ef': 43.5*10**6, # [J/kg]\n                   'Contingency Fuel': 130, # [kg]\n                   'Eta Gas Turbine Model': 'constant',\n                   'Eta Gas Turbine': 0.22,\n                   'Eta Gearbox': 0.96,\n                   'Eta Propulsive Model': 'constant',\n                   'Eta Propulsive': 0.9,\n                   'Eta Electric Motor 1': 0.96,    #for serial config\n                   'Eta Electric Motor 2': 0.96,    #for serial config\n                   'Eta Electric Motor': 0.98,      #for parallel config\n                   'Eta PMAD': 0.99,\n                   'Specific Power Powertrain': [3900,7700], # [W/kg] \n                   'Specific Power PMAD': [2200,2200,2200] # [W/kg]\n                   }\n</pre> EnergyInput = {'Ef': 43.5*10**6, # [J/kg]                    'Contingency Fuel': 130, # [kg]                    'Eta Gas Turbine Model': 'constant',                    'Eta Gas Turbine': 0.22,                    'Eta Gearbox': 0.96,                    'Eta Propulsive Model': 'constant',                    'Eta Propulsive': 0.9,                    'Eta Electric Motor 1': 0.96,    #for serial config                    'Eta Electric Motor 2': 0.96,    #for serial config                    'Eta Electric Motor': 0.98,      #for parallel config                    'Eta PMAD': 0.99,                    'Specific Power Powertrain': [3900,7700], # [W/kg]                     'Specific Power PMAD': [2200,2200,2200] # [W/kg]                    } In\u00a0[9]: Copied! <pre>CellInput = {\n    'Class': \"II\",\n    'Model':'Finger-Cell-Thermal', # used only if Class=II\n    'SpecificPower': 8000, # [W/kg] if Class=II it can be (i) assigned, or (ii) None and computed from cell properties\n    'SpecificEnergy': 1500, # [Wh/kg]\n    'Minimum SOC': 0.2,\n    'Pack Voltage':800, # [V] used only if Class=II\n    'Initial temperature': 25, # [\u00b0C] used only if Class=II\n    'Max operative temperature':50 # [\u00b0C] used only if Class=II\n    }\n</pre> CellInput = {     'Class': \"II\",     'Model':'Finger-Cell-Thermal', # used only if Class=II     'SpecificPower': 8000, # [W/kg] if Class=II it can be (i) assigned, or (ii) None and computed from cell properties     'SpecificEnergy': 1500, # [Wh/kg]     'Minimum SOC': 0.2,     'Pack Voltage':800, # [V] used only if Class=II     'Initial temperature': 25, # [\u00b0C] used only if Class=II     'Max operative temperature':50 # [\u00b0C] used only if Class=II     } In\u00a0[10]: Copied! <pre>AerodynamicsInput = {'AnalyticPolar': {'type': 'Quadratic', 'input': {'AR': 11, 'e_osw': 0.8}},\n                    'Take Off Cl': 1.9,\n                     'Landing Cl': 1.9,\n                     'Minimum Cl': 0.20,\n                     'Cd0': 0.017}\n</pre> AerodynamicsInput = {'AnalyticPolar': {'type': 'Quadratic', 'input': {'AR': 11, 'e_osw': 0.8}},                     'Take Off Cl': 1.9,                      'Landing Cl': 1.9,                      'Minimum Cl': 0.20,                      'Cd0': 0.017}  In\u00a0[11]: Copied! <pre>WellToTankInput = {'Eta Charge': 0.95,\n                   'Eta Grid': 1.,\n                   'Eta Extraction': 1.,\n                   'Eta Production': 1.,\n                   'Eta Transportation': 0.25}\n\nClimateImpactInput = {'H': 100, 'N':1.6e7, 'Y':30, 'EINOx_model':'Filippone', 'WTW_CO2': 8.30e-3, 'Grid_CO2': 9.36e-2}\n</pre> WellToTankInput = {'Eta Charge': 0.95,                    'Eta Grid': 1.,                    'Eta Extraction': 1.,                    'Eta Production': 1.,                    'Eta Transportation': 0.25}  ClimateImpactInput = {'H': 100, 'N':1.6e7, 'Y':30, 'EINOx_model':'Filippone', 'WTW_CO2': 8.30e-3, 'Grid_CO2': 9.36e-2} <p>Set aircraft power configuration and structural weight model</p> In\u00a0[12]: Copied! <pre>myaircraft.Configuration = 'Hybrid'\nmyaircraft.HybridType = 'Parallel'\nmyaircraft.weight.Class = 'I'\nmyaircraft.AircraftType = 'ATR'\n</pre> myaircraft.Configuration = 'Hybrid' myaircraft.HybridType = 'Parallel' myaircraft.weight.Class = 'I' myaircraft.AircraftType = 'ATR' <p>Import input dictionaries</p> In\u00a0[13]: Copied! <pre>myaircraft.ReadInput(AerodynamicsInput, \n                     ConstraintsInput,\n                     MissionInput,\n                     EnergyInput,\n                     MissionStages,\n                     DiversionStages, \n                     LoiterStages=None, \n                     WellToTankInput=WellToTankInput, \n                     CellInput=CellInput, \n                     ClimateImpactInput=ClimateImpactInput, \n                     PropellerInput=None\n                     )\n</pre> myaircraft.ReadInput(AerodynamicsInput,                       ConstraintsInput,                      MissionInput,                      EnergyInput,                      MissionStages,                      DiversionStages,                       LoiterStages=None,                       WellToTankInput=WellToTankInput,                       CellInput=CellInput,                       ClimateImpactInput=ClimateImpactInput,                       PropellerInput=None                      ) <p>Either run the Constraint Analysis....</p> In\u00a0[14]: Copied! <pre>myaircraft.constraint.FindDesignPoint()\nprint('----------------------------------------------')\nprint(f'Design wing loading W/S: {myaircraft.DesignWTOoS:.1f} [N/m^2]')\nprint(f'Design power-to-mass ratio P/W: {myaircraft.DesignPW:.2f} [W/kg]')\nprint('----------------------------------------------')\n</pre> myaircraft.constraint.FindDesignPoint() print('----------------------------------------------') print(f'Design wing loading W/S: {myaircraft.DesignWTOoS:.1f} [N/m^2]') print(f'Design power-to-mass ratio P/W: {myaircraft.DesignPW:.2f} [W/kg]') print('----------------------------------------------') <pre>----------------------------------------------\nDesign wing loading W/S: 3293.8 [N/m^2]\nDesign power-to-mass ratio P/W: 194.91 [W/kg]\n----------------------------------------------\n</pre> In\u00a0[15]: Copied! <pre>plt.plot(myaircraft.constraint.WTOoS,myaircraft.constraint.PWCruise, label='Cruise')\nplt.plot(myaircraft.constraint.WTOoS,myaircraft.constraint.PWTakeOff, label='Take Off')\nplt.plot(myaircraft.constraint.WTOoS,myaircraft.constraint.PWAEOClimb, label='Climb')\nplt.plot(myaircraft.constraint.WTOoS,myaircraft.constraint.PWOEIClimb, label='Climb OEI')\nplt.plot(myaircraft.constraint.WTOoS,myaircraft.constraint.PWTurn, label='Turn')\nplt.plot(myaircraft.constraint.WTOoS,myaircraft.constraint.PWCeiling, label='Ceiling')\nplt.plot(myaircraft.constraint.WTOoS,myaircraft.constraint.PWAcceleration, label='Acceleration')\nplt.plot(myaircraft.constraint.WTOoSLanding,myaircraft. constraint.PWLanding, label='Landing')\nplt.plot(myaircraft.DesignWTOoS, myaircraft.DesignPW, marker='o', markersize = 10, markerfacecolor = 'red', markeredgecolor = 'black')\n# plt.plot(performance.WTOoSTorenbeek, performance.PWTorenbeek, label='Torenbeek')\nplt.ylim([0, 300])\nplt.xlim([0, 7000])\nplt.legend()\nplt.grid(visible=True)\nplt.xlabel('$W_{TO}/S$')\nplt.ylabel('$P/W_{TO}$')\nplt.show()\n</pre> plt.plot(myaircraft.constraint.WTOoS,myaircraft.constraint.PWCruise, label='Cruise') plt.plot(myaircraft.constraint.WTOoS,myaircraft.constraint.PWTakeOff, label='Take Off') plt.plot(myaircraft.constraint.WTOoS,myaircraft.constraint.PWAEOClimb, label='Climb') plt.plot(myaircraft.constraint.WTOoS,myaircraft.constraint.PWOEIClimb, label='Climb OEI') plt.plot(myaircraft.constraint.WTOoS,myaircraft.constraint.PWTurn, label='Turn') plt.plot(myaircraft.constraint.WTOoS,myaircraft.constraint.PWCeiling, label='Ceiling') plt.plot(myaircraft.constraint.WTOoS,myaircraft.constraint.PWAcceleration, label='Acceleration') plt.plot(myaircraft.constraint.WTOoSLanding,myaircraft. constraint.PWLanding, label='Landing') plt.plot(myaircraft.DesignWTOoS, myaircraft.DesignPW, marker='o', markersize = 10, markerfacecolor = 'red', markeredgecolor = 'black') # plt.plot(performance.WTOoSTorenbeek, performance.PWTorenbeek, label='Torenbeek') plt.ylim([0, 300]) plt.xlim([0, 7000]) plt.legend() plt.grid(visible=True) plt.xlabel('$W_{TO}/S$') plt.ylabel('$P/W_{TO}$') plt.show() <p>... or manually assign a wing loading</p> In\u00a0[16]: Copied! <pre># myaircraft.DesignWTOoS = 3323\n</pre> # myaircraft.DesignWTOoS = 3323 <p>Run Mission analysis to define the aircraft's masses</p> In\u00a0[17]: Copied! <pre>myaircraft.weight.WeightEstimation()\n</pre> myaircraft.weight.WeightEstimation() <pre>max=58 and min=56\nOptimal n 57\nmax=341 and min=340\nOptimal n 341\nmax=119 and min=118\nOptimal n 119\nmax=125 and min=124\nOptimal n 125\nmax=125 and min=124\nOptimal n 125\nmax=125 and min=124\nOptimal n 125\nmax=125 and min=124\nOptimal n 125\n</pre> <p>Wing surface can be readily estimated as S = WTO/(WTO/S)</p> In\u00a0[18]: Copied! <pre>myaircraft.WingSurface = myaircraft.weight.WTO / myaircraft.DesignWTOoS * 9.81\n</pre> myaircraft.WingSurface = myaircraft.weight.WTO / myaircraft.DesignWTOoS * 9.81 <p>Well to tank impact is evaluated as a post-process</p> In\u00a0[19]: Copied! <pre>if (myaircraft.Configuration == 'Hybrid' and WellToTankInput is not None):\n    myaircraft.welltowake.EvaluateSource()\n</pre> if (myaircraft.Configuration == 'Hybrid' and WellToTankInput is not None):     myaircraft.welltowake.EvaluateSource() <p>A summary of the preliminary design:</p> In\u00a0[20]: Copied! <pre>myaircraft.Print_Aircraft_Design_Summary()\n</pre> myaircraft.Print_Aircraft_Design_Summary() <pre>Fuel mass (trip + altn + loiter): 1572.8 [Kg]\nBlock Fuel mass:                  1702.8 [Kg]\nBattery mass:                     1686.2 [Kg]\nStructure:                        12028.6 [Kg]\nPowertrain mass:                  1432.9 [Kg]\nEmpty Weight:                     15647.8 [Kg]\nZero Fuel Weight:                 20207.8 [Kg]\n----------------------------------------\nTakeoff Weight:                   21910.5 [Kg]\n \nSource Energy:                    281499.3 [MJ]\nPsi:                              0.0278 [-]\n \nWing Surface:                     65.3 [m^2]\n \nTakeOff engine shaft peak power:  4942.3 [KW]\nCLB/CRZ engine shaft peak power:  4072.2 [KW] @ 1503.5 [m]\n \nSizing phase for thermal powertrain:  Takeoff peak power\nThermal powertrain rating shaft power SLS rating: 4942.3 [kW]\n \n-------------Battery Specs-------------\nBattery Pack Energy:               2529.4 [kWh]\nBattery Pack Max Power:            13563.4 [kW]\nBattery Pack Specific Energy:      1500.0 [Wh/kg]\nBattery Pack Specific Power:       8.0 [kW/kg]\nBattery Configuration:             S-190 P-125\n</pre> <p>Tank to wake climate impact is evaluated as a post-process</p> In\u00a0[21]: Copied! <pre>myaircraft.MissionType = 'Continue'\nmyaircraft.climateimpact.calculate_mission_emissions()\nprint(myaircraft.climateimpact.mission_emissions)\n\nmyaircraft.climateimpact.ATR()\n</pre> myaircraft.MissionType = 'Continue' myaircraft.climateimpact.calculate_mission_emissions() print(myaircraft.climateimpact.mission_emissions)  myaircraft.climateimpact.ATR()  <pre>{'co2': 6271.1552711333725, 'h2o': 1981.711995716157, 'so4': 0.3145574596374852, 'soot': 0.06291149192749705, 'nox': 19.691116859261136}\n</pre> Out[21]: <pre>0.0028135789146068652</pre> <p>Some plots:</p> In\u00a0[22]: Copied! <pre>times = np.linspace(0,mission.profile.MissionTime2,num = 1000)\nplt.plot(times/60,[mission.profile.SuppliedPowerRatio(t) for t in times], 'b')\n#plt.plot(myaircraft.mission.profile.Breaks,np.ones(6)*0.05, '*')\nplt.grid(visible=True)\nplt.xlabel('t [min]')\nplt.ylabel('Phi')\nplt.show()\n</pre> times = np.linspace(0,mission.profile.MissionTime2,num = 1000) plt.plot(times/60,[mission.profile.SuppliedPowerRatio(t) for t in times], 'b') #plt.plot(myaircraft.mission.profile.Breaks,np.ones(6)*0.05, '*') plt.grid(visible=True) plt.xlabel('t [min]') plt.ylabel('Phi') plt.show() In\u00a0[23]: Copied! <pre>times = np.array([])\nEf    = np.array([])\nEbat  = np.array([])\nbeta  = np.array([])\nsoc   = np.array([])\nfor array in mission.integral_solution:\n    times = np.concatenate([times, array.t])\n    Ef    = np.concatenate([Ef   , array.y[0]])\n    Ebat  = np.concatenate([Ebat , array.y[1]])\n    beta  = np.concatenate([beta , array.y[2]])\n</pre> times = np.array([]) Ef    = np.array([]) Ebat  = np.array([]) beta  = np.array([]) soc   = np.array([]) for array in mission.integral_solution:     times = np.concatenate([times, array.t])     Ef    = np.concatenate([Ef   , array.y[0]])     Ebat  = np.concatenate([Ebat , array.y[1]])     beta  = np.concatenate([beta , array.y[2]]) <p>Takeoff propulsive power</p> In\u00a0[24]: Copied! <pre>myaircraft.performance.TakeOff(myaircraft.DesignWTOoS,myaircraft.constraint.TakeOffConstraints['Beta'], myaircraft.constraint.TakeOffConstraints['Altitude'],myaircraft.constraint.TakeOffConstraints['kTO'], myaircraft.constraint.TakeOffConstraints['sTO'], myaircraft.constraint.DISA, myaircraft.constraint.TakeOffConstraints['Speed'], myaircraft.constraint.TakeOffConstraints['Speed Type'])\n</pre> myaircraft.performance.TakeOff(myaircraft.DesignWTOoS,myaircraft.constraint.TakeOffConstraints['Beta'], myaircraft.constraint.TakeOffConstraints['Altitude'],myaircraft.constraint.TakeOffConstraints['kTO'], myaircraft.constraint.TakeOffConstraints['sTO'], myaircraft.constraint.DISA, myaircraft.constraint.TakeOffConstraints['Speed'], myaircraft.constraint.TakeOffConstraints['Speed Type']) Out[24]: <pre>194.88837279163596</pre> <p>Maximum mission Propusive Power over Takeoff Mass</p> In\u00a0[25]: Copied! <pre>max([myaircraft.performance.PoWTO(myaircraft.DesignWTOoS,beta[t],myaircraft.mission.profile.PowerExcess(times[t]),1,myaircraft.mission.profile.Altitude(times[t]),myaircraft.mission.DISA,myaircraft.mission.profile.Velocity(times[t]),'TAS') for t in range(len(times))])\n</pre> max([myaircraft.performance.PoWTO(myaircraft.DesignWTOoS,beta[t],myaircraft.mission.profile.PowerExcess(times[t]),1,myaircraft.mission.profile.Altitude(times[t]),myaircraft.mission.DISA,myaircraft.mission.profile.Velocity(times[t]),'TAS') for t in range(len(times))]) Out[25]: <pre>160.5799464672633</pre> In\u00a0[26]: Copied! <pre>plt.plot(times/60,[myaircraft.performance.PoWTO(myaircraft.DesignWTOoS,beta[t],myaircraft.mission.profile.PowerExcess(times[t]),1,myaircraft.mission.profile.Altitude(times[t]),myaircraft.mission.DISA,myaircraft.mission.profile.Velocity(times[t]),'TAS') for t in range(len(times))], 'b')\nplt.grid(visible=True)\nplt.xlabel('t [min]')\nplt.ylabel('Pp/W')\nplt.show()\n</pre> plt.plot(times/60,[myaircraft.performance.PoWTO(myaircraft.DesignWTOoS,beta[t],myaircraft.mission.profile.PowerExcess(times[t]),1,myaircraft.mission.profile.Altitude(times[t]),myaircraft.mission.DISA,myaircraft.mission.profile.Velocity(times[t]),'TAS') for t in range(len(times))], 'b') plt.grid(visible=True) plt.xlabel('t [min]') plt.ylabel('Pp/W') plt.show() In\u00a0[27]: Copied! <pre>plt.plot(times/60,[(myaircraft.weight.WTO/1000) * myaircraft.performance.PoWTO(myaircraft.DesignWTOoS,beta[t],myaircraft.mission.profile.PowerExcess(times[t]),1,myaircraft.mission.profile.Altitude(times[t]),myaircraft.mission.DISA,myaircraft.mission.profile.Velocity(times[t]),'TAS') for t in range(len(times))], 'b')\nplt.grid(visible=True)\nplt.xlabel('t [min]')\nplt.ylabel('Pp [kW]')\nplt.show()\n</pre> plt.plot(times/60,[(myaircraft.weight.WTO/1000) * myaircraft.performance.PoWTO(myaircraft.DesignWTOoS,beta[t],myaircraft.mission.profile.PowerExcess(times[t]),1,myaircraft.mission.profile.Altitude(times[t]),myaircraft.mission.DISA,myaircraft.mission.profile.Velocity(times[t]),'TAS') for t in range(len(times))], 'b') plt.grid(visible=True) plt.xlabel('t [min]') plt.ylabel('Pp [kW]') plt.show() In\u00a0[28]: Copied! <pre>plt.plot(times,Ef, 'b')\n#plt.plot(myaircraft.mission.profile.Breaks,np.ones(6)*0.05, '*')\nplt.grid(visible=True)\nplt.xlabel('t [min]')\nplt.ylabel('Efuel')\nplt.show()\n</pre> plt.plot(times,Ef, 'b') #plt.plot(myaircraft.mission.profile.Breaks,np.ones(6)*0.05, '*') plt.grid(visible=True) plt.xlabel('t [min]') plt.ylabel('Efuel') plt.show() In\u00a0[29]: Copied! <pre>plt.plot(times,beta, 'b')\n#plt.plot(myaircraft.mission.profile.Breaks,np.ones(6)*0.05, '*')\nplt.grid(visible=True)\nplt.xlabel('t [min]')\nplt.ylabel('beta')\nplt.show()\n</pre> plt.plot(times,beta, 'b') #plt.plot(myaircraft.mission.profile.Breaks,np.ones(6)*0.05, '*') plt.grid(visible=True) plt.xlabel('t [min]') plt.ylabel('beta') plt.show() In\u00a0[30]: Copied! <pre>plt.plot(times/60,mission.profile.Altitude(times))\nplt.grid(visible=True)\nplt.xlabel('t [min]')\nplt.ylabel('Altitude [m]')\nplt.show()\n</pre> plt.plot(times/60,mission.profile.Altitude(times)) plt.grid(visible=True) plt.xlabel('t [min]') plt.ylabel('Altitude [m]') plt.show()"},{"location":"getting-started/running-your-first-mission/#phlygreen-tutorial-sizing-a-parallel-hybrid-aircraft","title":"PhlyGreen Tutorial: sizing a parallel-hybrid aircraft\u00b6","text":""},{"location":"getting-started/theory/","title":"Theoretical Reference","text":"<p><code>PhlyGreen</code> (fl\u028c\u026a\u0261ri\u02d0n) is a Python object-oriented code for conducting preliminary design analysis on hybrid/electric aircraft. The <code>PhlyGreen</code> architecture facilitates the definition of Multidisciplinary Design Optimization (MDO) problems and the implementation of several discipline blocks into the optimization loop. </p>"},{"location":"getting-started/theory/#aircraft-preliminary-design-basics","title":"Aircraft preliminary design basics","text":"<p>The analysis starts from the point model energy balance equation obtained along the aircraft velocity direction:</p> \\[ \\frac{P_p}{W_{TO}} = g \\,\\frac{1}{W_{TO}/S}\\, q\\, V\\, C_D + \\beta\\, P_s, \\] <p>where \\(g\\) is the gravity acceleration, \\(q=1/2 \\rho V^2\\) is the dynamic pressure, \\(\\beta=W(t)/W_{TO}\\) is the instantaneous-to-take-off mass ratio, \\(C_D\\) is the drag coefficient, and \\(P_s\\) the specific excess power. The parameters \\(q\\),\\(C_D\\),\\(\\beta\\),\\(P_s\\) depend on the instantaneous flight condition, i.e., velocity \\(V\\), altitude \\(h\\) and attitude. More specifically, \\(C_D(C_L)\\) requires an aerodynamic polar model. The energy balance equation can be specified for each of the performance constraints denoted by the Top-level aircraft requirements (TLARs), designating a feasible space in terms of power-to-weight ratio \\(P_p/W_{TO}\\) and wing loading \\(W_{TO}/S\\). </p> <p>The powertrain model enables the generalization of the propulsive architecture. In fact, by considering the power flow pathways within a generic powertrain, a system of equations can be formulated as \\(\\sum P_{out} = \\sum \\eta_i P_{in,i}\\). If a hybrid parallel powertrain is considered, as done in the following, the linear system of equations is written as:</p> \\[ \\begin{bmatrix} -\\eta_{GT} &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; -\\eta_{GB} &amp; -\\eta_{GB} &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0  &amp; 1 &amp; -\\eta_{PM} &amp; 0 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 &amp; -\\eta_{EM} &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; -\\eta_P &amp; 0 &amp; 0 &amp; 1 \\\\ \\varphi &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \\varphi - 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1  \\end{bmatrix} \\begin{bmatrix}     P_f \\\\     P_{gt} \\\\     P_{gb} \\\\     P_{sh} \\\\     P_{e} \\\\     P_{bat} \\\\     P_p \\end{bmatrix} = \\begin{bmatrix}     0 \\\\     0 \\\\      0 \\\\     0 \\\\      0 \\\\     0 \\\\     P_p \\end{bmatrix} \\] <p>where </p> \\[ \\varphi = \\frac{P_{bat}}{P_{bat} + P_f} \\in [0, 1] \\] <p>is the instantaneous supplied power ratio, representing the portion of electrical power used by the engine on the total power reserve. In the system above, \\(\\eta_{GT}\\) is the gas-turbine turbo-shaft engine efficiency, \\(\\eta_{GB}\\) is the gearbox transmission efficiency, \\(\\eta_{EM}\\) is the electric motor efficiency, \\(\\eta_{PM}\\) is the power electronics efficiency, \\(\\eta_{P}\\) is the propeller efficiency, while \\(P_p\\) is the propulsive power (i.e. the power transmitted by the propeller to the airflow), \\(P_{sh}\\) is the shaft power (i.e. the power transmitted by the shaft to the propeller), \\(P_{gb}\\) is the gearbox transmitted power, \\(P_{gt}\\) is the power generated by the GT engine, \\(P_{e}\\) is the electric power generated by the electric motor, \\(P_{bat}\\) is the power required at the battery, and \\(P_f\\) is the power extracted from the fuel. To give a simple example, in a traditional configuration, the following chain holds:</p> \\[ P_f = \\frac{1}{\\eta_{GT}}\\cdot \\frac{1}{\\eta_{sh}} \\cdot \\frac{1}{\\eta_{GB}} \\cdot \\frac{1}{\\eta_{P}} \\cdot P_p. \\] <p>In other words, the efficiency chain amplifies the required aircraft power (due to drag) to a much higher fuel power. </p> <p>By solving the linear system above, the power-to-weight ratios referred to both fuel (P_f/W_{TO}) and battery (P_{bat}/W_{TO}) can be determined. These values can then be integrated in time along the mission profile to ascertain the cumulative energy contributions from the electric and fuel sources:</p> \\[ E_i = \\int_{t_s}^{t_e} \\frac{P_i}{W_{TO}} \\left( \\varphi(t), \\beta(t), h(t), V(t),\\frac{W_{TO}}{S} \\right) \\, W_{TO} \\, dt \\, , \\] <p>where the index \\(i\\) is representative of the fuel and battery sources. Note that the supplied power ratio \\(\\varphi\\) is an instantaneous quantity as well, which can be varied to define the most adequate hybridization strategy. </p> <p>The energy produced by burning fuel can be easily converted into the fuel weight \\(W_F\\) by using the fuel heating value, while the battery weight will be computed following two different methodologies: a) a low-fidelity formulation based on the most demanding scenario in terms of power and energy capacity along the mission profile and b) a higher-fidelity which accounts for the State-of-Charge (SoC) effects on a cell-level and computes the number of required serial and parallel cell numbers. The latter formulation is further discussed in Battery Module user guide.</p> <p>The total weight breakdown is completed by the operative empty weight (OEW) \\(W_{OE}\\) and payload \\(W_{PL}\\):</p> \\[ W_{TO} = W_{F} + W_{bat} + W_{PL} + W_{OE} \\; \\; , \\] <p>where </p> \\[ W_{OE} = W_{ST} + W_{PT} + W_{crew} \\; \\; . \\] <p>The structural weight \\(W_{ST}\\) can be estimated again following two approaches: a) a low-fidelity quick estimate based on empirical correlations between \\(W_{ST}\\) and \\(W_{TO}\\) of existing aircraft (class I); b) the more detailed estimations proposed in the FLOPS software, which consider the structural mass as the sum of the masses of several aircraft components (class II). The powertrain weight is estimated using the specific power of the components of the chosen architecture, considering the peak power requirement across the mission, take-off, and the TLARs. Given that the value of \\(W_{TO}\\) is needed in the intgeral equation above, the weight estimation necessitates an iterative procedure, such as Brent's method. The mission profile is modeled as a continuous function to integrate using the Backward differentiation formula (BDF) solver, an adaptive step method that does not rely on a priori time discretization of the mission.</p>"},{"location":"getting-started/theory/#references","title":"References","text":"<ul> <li>Roskam, J., Airplane Design, DARcorporation, 1985.</li> <li>Torenbeek, E., Synthesis of Subsonic Airplane Design: an Introduction to the Preliminary Design of Subsonic General Aviation and Transport Aircraft, with Emphasis on Layout, Aerodynamic Design, Propulsion and Performance, Springer Science &amp; Business Media, 2013</li> <li>Mattingly, J. D., Aircraft Engine Design, AIAA, 2002.</li> <li>Isikveren, A. T., Kaiser, S., Pornet, C., and Vratny, P. C., \u201cPre-design Strategies and Sizing Techniques for Dual-energy Aircraft,\u201d Aircraft Engineering and Aerospace Technology: An International Journal, Vol. 86, No. 6, 2014, pp. 525\u2013542.</li> <li>Pornet, C., Gologan, C., Vratny, P. C., Seitz, A., Schmitz, O., Isikveren, A. T., and Hornung, M., \u201cMethodology for Sizing and Performance Assessment of Hybrid Energy Aircraft,\u201d Journal of Aircraft, Vol. 52, No. 1, 2015, pp. 341\u2013352.</li> <li>Zamboni, J., Vos, R., Emeneth, M., and Schneegans, A., \u201cA Method for the Conceptual Design of Hybrid Electric Aircraft,\u201d AIAA Scitech 2019 Forum, 2019, p. 1587</li> <li>Orefice, F., Della Vecchia, P., Ciliberti, D., and Nicolosi, F., \u201cAircraft Conceptual Design Including Powertrain System Architecture and Distributed Propulsion,\u201d 2019 AIAA/IEEE Electric Aircraft Technologies Symposium (EATS), IEEE, 2019, pp.1\u201320</li> <li>de Vries, R., Brown, M. T., and Vos, R., \u201cA Preliminary Sizing Method for Hybrid-Electric Aircraft Including Aero-Propulsive Interaction Effects,\u201d 2018 Aviation Technology, Integration, and Operations Conference, 2018, p. 4228.</li> <li>De Vries, R., Brown, M., and Vos, R., \u201cPreliminary Sizing Method for Hybrid-Electric Distributed-Propulsion Aircraft,\u201d Journal of Aircraft, Vol. 56, No. 6, 2019, pp. 2172\u20132188</li> <li>Finger, D. F., Braun, C., and Bil, C., \u201cImpact of Engine Failure Constraints on the Initial Sizing of Hybrid-Electric GA Aircraft,\u201d AIAA Scitech 2019 Forum, 2019, p. 1812</li> <li>Proesmans, P.-J., and Vos, R., \u201cAirplane Design Optimization for Minimal Global Warming Impact,\u201d Journal of Aircraft, Vol. 59, No. 5, 2022, pp. 1363\u20131381</li> <li>Filippone, A., and Bojdo, N., \u201cStatistical Model for Gas Turbine Engines Exhaust Emissions,\u201d Transportation Research Part D: Transport and Environment, Vol. 59, 2018, pp. 451\u2013463</li> <li>Souleman Njoya Motapon, Alexandre Lupien-Bedard, Louis-A. Dessaint, Handy Fortin-Blanchette, and Kamal Al-Haddad. A Generic Electrothermal Li-ion Battery Model for Rapid Evaluation of Cell Temperature Temporal Evolution. IEEE Transactions on Industrial Electronics, 64(2):998\u20131008, 2017.</li> </ul>"},{"location":"user-guide/aircraft/","title":"Aircraft Model","text":"<p>This page documents the <code>Aircraft</code> class, the central container that coordinates constraint, mission, performance, systems, weight, climateimpact, and well\u2011to\u2011wake modules in PhlyGreen.</p>"},{"location":"user-guide/aircraft/#overview","title":"Overview","text":"<p>The <code>Aircraft</code> class is responsible for:</p> <ul> <li>Storing all high\u2011level aircraft configuration and inputs  </li> <li>Initializing subsystem models </li> <li>Passing inputs between these subsystems  </li> <li>Coordinating the full simulation workflow</li> </ul> <p>It acts as a data and logic hub, ensuring that all parts of the framework work with consistent and synchronized parameters.</p>"},{"location":"user-guide/aircraft/#key-attributes","title":"Key Attributes","text":""},{"location":"user-guide/aircraft/#configuration-parameters","title":"Configuration Parameters","text":"<ul> <li><code>Name</code> \u2014 aircraft name  </li> <li><code>Configuration</code> \u2014 <code>\"Traditional\"</code> or <code>\"Hybrid\"</code> </li> <li><code>HybridType</code> \u2014 <code>\"Serial\"</code> or <code>\"Parallel\"</code> (if hybrid)  </li> <li><code>Class</code> \u2014 weight estimation fidelity: <code>\"I\"</code> (simplified) or <code>\"II\"</code> (FLOPS\u2011based)</li> <li><code>AircraftType</code> \u2014 structural model selection</li> </ul>"},{"location":"user-guide/aircraft/#submodels","title":"Sub\u2011Models","text":"<p>The Aircraft object instantiation requires instances of the submodules classes as arguments:</p> <ul> <li><code>Systems.Powertrain</code> \u2014 gas\u2011turbine/electric/hybrid power models  </li> <li><code>Systems.Structures</code> \u2014 structural weight estimation model</li> <li><code>Systems.Aerodynamics</code> \u2014 aerodynamic polar model </li> <li><code>Performance</code> \u2014 aircraft performance equations  </li> <li><code>Mission</code> \u2014 mission simulation module and mission profile </li> <li><code>Weight</code> \u2014 global mass iteration loop </li> <li><code>Constraint</code> \u2014 constraint diagram equations </li> <li><code>WellToWake</code> \u2014 well\u2011to\u2011wake energy model (fuel + battery)</li> <li><code>Battery</code> \u2014 battery electro\u2011thermal model  </li> <li><code>ClimateImpact</code> \u2014 climate impact model</li> </ul> <p>Each is wired to the same parent aircraft instance.</p> <p></p>"},{"location":"user-guide/battery/","title":"Battery Model","text":"<p>This page documents the high\u2011fidelity electro\u2011thermal battery model in PhlyGreen.</p>"},{"location":"user-guide/battery/#1-overview","title":"1. Overview","text":"<p>PhlyGreen\u2019s Battery module provides a dynamic, temperature\u2011aware, physics\u2011based representation of a lithium\u2011ion battery pack suitable for hybrid\u2011electric aircraft preliminary design.</p> <p>It simulates:</p> <ul> <li>A representative cell, based on a modified Shepherd equation  </li> <li>Its thermal behaviour using a lumped\u2011parameter model  </li> <li>A complete battery pack, built via series (<code>S</code>) and parallel (<code>P</code>) configuration  </li> <li>Full operational constraint handling (voltage, SOC, current, temperature)  </li> <li>A sizing loop integrated into the aircraft\u2019s WTO iteration  </li> </ul> <p>The model is based on empirical cell parameters (selected in <code>Cell_Models</code>) and is configurable via user\u2011provided battery settings.</p>"},{"location":"user-guide/battery/#2-battery-state-variables","title":"2. Battery State Variables","text":"<p>At every timestep, the battery tracks three continuous state variables:</p> <ul> <li>Cell current: <code>i</code> </li> <li>Spent charge (Ah):  </li> </ul> <p>$$ i_t(t+\\Delta t) = i_t(t) + \\frac{i\\,\\Delta t}{3600} $$</p> <ul> <li>Temperature: \\( T \\)</li> </ul> <p>The State of Charge (SOC) is defined as:</p> \\[ \\text{SOC} = 1 - \\frac{i_t}{Q} \\] <p>where \\( Q \\) is the cell capacity.</p> <p>A <code>BatteryError</code> is raised if SOC leaves the allowable range:</p> \\[ \\text{SOC}_{\\min} \\le \\text{SOC} \\le 1 \\]"},{"location":"user-guide/battery/#3-pack-architecture","title":"3. Pack Architecture","text":"<p>A battery pack is constructed as:</p> <ul> <li><code>S</code> cells in series \u2192 increases voltage  </li> <li><code>P</code> cells in parallel \u2192 increases current capability  </li> </ul> <p>Thus:</p> \\[ V_{\\text{pack}} = S \\, V_{\\text{cell}} \\] \\[ I_{\\text{pack}} = P \\, i_{\\text{cell}} \\] <p>Pack-level capacity and energy:</p> \\[ Q_{\\text{pack}} = P \\, Q \\] \\[ E_{\\text{pack}} = S \\, P \\, E_{\\text{cell}} \\]"},{"location":"user-guide/battery/#4-cell-electrical-model","title":"4. Cell Electrical Model","text":""},{"location":"user-guide/battery/#modified-shepherd-equation-temperatureaware","title":"Modified Shepherd Equation (Temperature\u2011Aware)","text":"<p>The cell voltage is computed using a temperature\u2011corrected modified Shepherd model:</p> \\[ V = E_0(T)     - K(T)\\left(\\frac{Q}{Q - i_t}\\right)i_t     + A(T)e^{-B(T)i_t}     - i\\,R(T) \\] <p>Where:</p> <ul> <li>\\( E_0(T) \\) \u2014 open\u2011circuit voltage (with thermal correction)  </li> <li>\\( K(T) \\) \u2014 polarization constant  </li> <li>\\( A(T), B(T) \\) \u2014 exponential zone parameters  </li> <li>\\( R(T) \\) \u2014 internal resistance (Arrhenius\u2011corrected)  </li> </ul>"},{"location":"user-guide/battery/#solving-for-current-from-a-required-power","title":"Solving for Current from a Required Power","text":"<p>Given a required pack power \\( P_{\\text{pack}} \\), the battery solves:</p> \\[ P_{\\text{cell}} = \\frac{P_{\\text{pack}}}{S\\,P} \\] \\[ P_{\\text{cell}} = V(i)\\, i \\] <p>This becomes a quadratic equation:</p> \\[ a i^2 + b i + c = 0 \\] <p>Where:</p> <ul> <li>\\( a = -(R + K_r) \\) with \\( K_r = K Q/(Q-i_t) \\) </li> <li>\\( b = E_0 + A e^{-Bi_t} - i_t K_r \\) </li> <li>\\( c = -P_{\\text{cell}} \\)</li> </ul> <p>The physically meaningful root is selected:</p> \\[ i = \\frac{-b + \\sqrt{b^2 - 4ac}}{2a} \\] <p>If the discriminant is negative:</p> \\[ b^2 - 4ac &lt; 0 \\quad\\Rightarrow\\quad \\text{BatteryError} \\]"},{"location":"user-guide/battery/#5-thermal-model","title":"5. Thermal Model","text":""},{"location":"user-guide/battery/#lumpedparameter-singlenode-cell-temperature","title":"Lumped\u2011Parameter Single\u2011Node Cell Temperature","text":"<p>The cell temperature evolves according to:</p> \\[ \\frac{dT}{dt} = \\frac{Q_{\\text{loss}}}{C_{\\text{th}}}                + \\frac{T_{\\infty} - T}{R_{\\text{th}}\\, C_{\\text{th}}} \\] <p>Where:</p> <ul> <li>\\( C_{\\text{th}} \\) \u2014 thermal capacitance  </li> <li>\\( R_{\\text{th}} \\) \u2014 total thermal resistance  </li> </ul>"},{"location":"user-guide/battery/#heat-generation","title":"Heat Generation","text":"\\[ Q_{\\text{loss}} = (V_{\\text{oc}} - V)i + \\frac{dE_0}{dT} i T \\]"},{"location":"user-guide/battery/#convection-cooling-model","title":"Convection Cooling Model","text":"\\[ h = \\max\\left[ 30\\left(\\frac{\\dot{m}/(A_{\\text{surf}}\\rho)}{5}\\right)^{0.8},\\; 2 \\right] \\] <p>with airflow proportional to losses:</p> \\[ \\dot{m} = a \\, Q_{\\text{loss}} \\]"},{"location":"user-guide/battery/#6-battery-sizing-loop","title":"6. Battery Sizing Loop","text":"<p>Inside the aircraft\u2019s WTO root\u2011finding solver:</p> <ol> <li>Guess <code>WTO</code> </li> <li>Guess <code>P_number</code> </li> <li>Run full mission simulation  </li> <li>During each timestep, battery state is updated  </li> <li>If any violation occurs:  <ul> <li>SOC too low  </li> <li>Voltage too low  </li> <li>Current &gt; max  </li> <li>Temperature out of range \u2192 A <code>BatteryError</code> is thrown  </li> </ul> </li> <li>Increase <code>P_number</code> and retry  </li> <li>Once feasible, compute pack weight  </li> <li>Continue WTO iteration  </li> </ol> <p>This ensures size is based on actual in\u2011mission behaviour, not just averaged metrics.</p>"},{"location":"user-guide/battery/#7-inputs","title":"7. Inputs","text":"<p>Battery configuration comes from <code>CellInput</code>:</p> <ul> <li><code>\"Class\"</code> \u2014 <code>\"I\"</code> (simple) or <code>\"II\"</code> (electro\u2011thermal)  </li> <li><code>\"Model\"</code> \u2014 reference into <code>Cell_Models</code> </li> <li><code>\"SpecificEnergy\"</code> override  </li> <li><code>\"SpecificPower\"</code> override  </li> <li><code>\"Pack Voltage\"</code> </li> <li><code>\"Minimum SOC\"</code> </li> <li><code>\"Initial temperature\"</code> </li> <li><code>\"Max operative temperature\"</code></li> </ul> <p>Cell models include:</p> <ul> <li>Mass, size, geometry  </li> <li>OCV constants  </li> <li>Polarization coefficients  </li> <li>Exponential coefficients  </li> <li>Arrhenius constants  </li> <li>Thermal properties  </li> </ul>"},{"location":"user-guide/battery/#8-outputs","title":"8. Outputs","text":"<p>Available throughout the simulation:</p> <ul> <li><code>Vout</code> \u2014 pack voltage  </li> <li><code>cell_Vout</code> \u2014 cell voltage  </li> <li><code>I_pack</code> and <code>i_cell</code> \u2014 total and per\u2011cell current  </li> <li><code>SOC</code> </li> <li><code>T</code> </li> <li><code>Q_loss</code> \u2014 thermal losses  </li> <li>Pack mass, volume, energy  </li> <li>Maximum deliverable power  </li> </ul>"},{"location":"user-guide/battery/#9-error-handling","title":"9. Error Handling","text":"<p>The battery throws structured exceptions:</p> <ul> <li><code>\"SOC_OUTSIDE_LIMITS\"</code> </li> <li><code>\"VOLTAGE_OUTSIDE_LIMITS\"</code> </li> <li><code>\"CURR_OUTSIDE_LIMITS\"</code> </li> <li><code>\"NEG_BATT_TEMP\"</code> </li> <li><code>\"BATT_UNDERPOWERED\"</code> </li> <li><code>\"TEMP_OUTSIDE_LIMITS\"</code> </li> </ul> <p>These allow the sizing algorithm to automatically increase P.</p>"},{"location":"user-guide/battery/#10-usage-example","title":"10. Usage Example","text":"<pre><code>battery = Battery(aircraft)\nbattery.SetInput()\nbattery.Configure(parallel_cells=48)\n\nI = battery.Power_2_current(P=150e3)\ndTdt, Qloss = battery.heatLoss(Ta=288, rho=1.225)\n\nbattery.it += I * dt / 3600\nbattery.T  += dTdt * dt\n</code></pre>"},{"location":"user-guide/battery/#11-limitations","title":"11. Limitations","text":"<ul> <li>Single\u2011node temperature model (no spatial gradients).  </li> <li>No ageing/SEI model.  </li> <li>Cooling system mass is not sized.  </li> <li>Discharge\u2011only model (no charging).  </li> </ul>"},{"location":"user-guide/battery/#references","title":"References","text":"<ul> <li> <p>Shepherd, C. M. Design of Primary and Secondary Cells: II. An Equation Describing Battery Discharge.    Journal of The Electrochemical Society, 112(7):657, 1965.</p> </li> <li> <p>Tremblay, O., &amp; Dessaint, L.-A. A Generic Battery Model for the Dynamic Simulation of Hybrid Electric Vehicles.    Proceedings of the 2007 IEEE Vehicle Power and Propulsion Conference, pp. 284\u2013289.</p> </li> <li> <p>Saw, L., Somasundaram, K., Ye, Y., &amp; Tay, A. Electro-thermal analysis of Lithium Iron Phosphate battery for electric vehicles.    Journal of Power Sources, 249:231\u2013238, 2014.</p> </li> </ul>"},{"location":"user-guide/mission/","title":"Mission and Flight Profile Module","text":"<p>This page documents the Mission and Profile modules of PhlyGreen. These modules define the aircraft\u2019s flight profile, instantaneous power and overall energy consumption, and provide the temporal backbone used by all sizing routines (weight, battery, powertrain, emissions).</p>"},{"location":"user-guide/mission/#1-overview","title":"1. Overview","text":"<p>The mission solver integrates the aircraft state along a sequence of flight segments:</p> <ul> <li>climb  </li> <li>cruise  </li> <li>descent  </li> <li>loiter  </li> <li>diversion  </li> </ul> <p>Taxi and Take-off phases are presently not integrated in time, but accounted for with assigned fuel mass fractions.</p> <p>Each segment prescribes:</p> <ul> <li>altitude trajectory  </li> <li>speed schedule  </li> <li>load factor  </li> <li>electrical/thermal power split  </li> </ul> <p>The Profile module generates the time\u2011resolved reference states (altitude, speed, flight path angle), while the Mission module performs the powertrain requests, energy integration, and battery/fuel usage.</p>"},{"location":"user-guide/mission/#2-mission-class-highlevel-responsibilities","title":"2. Mission Class \u2014 High\u2011Level Responsibilities","text":"<p>The <code>Mission</code> class:</p> <ul> <li>Reads user mission inputs (<code>MissionInput</code> dictionary)</li> <li>Builds the flight profile via the <code>Profile</code> class</li> <li>Computes instantaneous power using aerodynamic and performance models</li> <li>Integrates:</li> <li>battery power  </li> <li>gas turbine power  </li> <li>Detects mission failures (insufficient power, battery issues)</li> <li>Returns mission total energies used for sizing</li> </ul>"},{"location":"user-guide/mission/#3-flight-profile-generation-profile-class","title":"3. Flight Profile Generation (Profile Class)","text":"<p>The <code>Profile</code> class discretizes the flight profile. It stores vectors of:</p> <ul> <li><code>altitude[t]</code></li> <li><code>speed[t]</code></li> <li><code>flight_path_angle[t]</code></li> <li><code>load_factor[t]</code></li> </ul> <p>It supports the following segments:</p> <ul> <li>Climb</li> <li>Cruise</li> <li>Descent</li> <li>Loiter</li> <li>Diversion</li> </ul> <p>Each segment appends time\u2011resolved states to the global mission arrays.</p>"},{"location":"user-guide/mission/#4-mission-power-calculation","title":"4. Mission Power Calculation","text":"<p>At each timestep \\( t \\), the Mission module computes the required propulsive power using the aircraft\u2019s <code>Performance</code> instance:</p> \\[ P_{prop}(t)= W_{TO} \\left[ \\frac{q V}{W_{TO}/S}\\, C_D(C_L, M) + \\beta P_s \\right] \\] <p>where:</p> <ul> <li>\\( q = \\frac{1}{2}\\rho V^2 \\) </li> <li>\\( W_{TO}/S \\) wing loading  </li> <li>\\( C_L, C_D \\) aerodynamic coefficients  </li> <li>\\( \\beta \\) = weight fraction  </li> <li>\\( P_s \\) = excess power requirement for climb  </li> </ul> <p>The Mission module then calls the Powertrain module to split this power into:</p> <ul> <li>fuel power  </li> <li>battery power  </li> </ul> <p>depending on the configured architecture (tradition, serial hybrid, parallel hybrid).</p>"},{"location":"user-guide/mission/#5-energy-integration","title":"5. Energy Integration","text":""},{"location":"user-guide/mission/#51-battery-energy","title":"5.1 Battery Energy","text":"<p>The integrated battery power request yields:</p> \\[ E_{bat}(t+\\Delta t) = E_{bat}(t) +  \\int_{t}^{t+\\Delta t} \\frac{P_{bat}}{W_{TO}} \\left( \\varphi(t), \\beta(t), h(t), V(t),\\frac{W_{TO}}{S} \\right) \\, W_{TO} \\, dt \\, , \\] <p>where \\( P_{\\text{bat}} \\) is given by processing the propulsive power with the electrical efficiency chain.  If the Class II battery model is used, the current is computed:</p> \\[ I(t) = \\text{Battery.Power_2_current}(P_{\\text{bat}}) \\] <p>and the SOC evolution is:</p> \\[ \\text{SOC}(t+\\Delta t) = 1 - \\frac{i_t(t)+ I\\Delta t/3600}{Q} \\] <p>Battery temperature uses the thermal ODE:</p> \\[ \\frac{dT}{dt} = \\frac{Q_{\\text{loss}}}{C_{\\text{th}}} + \\frac{T_\\infty - T}{R_{\\text{th}}C_{\\text{th}}} \\]"},{"location":"user-guide/mission/#52-fuel-energy","title":"5.2 Fuel Energy","text":"<p>Fuel energy integration:</p> \\[ E_f(t+\\Delta t) = E_f(t) +  \\int_{t}^{t+\\Delta t} \\frac{P_f}{W_{TO}} \\left( \\varphi(t), \\beta(t), h(t), V(t),\\frac{W_{TO}}{S} \\right) \\, W_{TO} \\, dt \\, , \\] <p>where the fuel power is obtained by amplifying the propulsive power with the thermal efficiency chain.</p>"},{"location":"user-guide/mission/#6-segment-loop-core-mission-logic","title":"6. Segment Loop (Core Mission Logic)","text":"<p>Pseudocode equivalent to the Mission solver:</p> <pre><code>for each timestep t in mission_profile:\n    read altitude, speed, gamma\n    compute performance propulsive power Pp\n    request powertrain split\n    update fuel and battery states\n    check SOC, voltage, current, T\n    accumulate segment energy\n</code></pre> <p>If any constraint is violated, a <code>MissionError</code> or <code>BatteryError</code> is thrown, causing the aircraft sizing loop to increase P\u2011number or adjust weight.</p>"},{"location":"user-guide/mission/#7-mission-outputs","title":"7. Mission Outputs","text":"<p>After integrating the full mission, the module returns:</p> <ul> <li>Total mission fuel energy  </li> <li>Total mission battery energy  </li> <li>Total emissions (if enabled)  </li> <li>Segment\u2011by\u2011segment logs (power, altitude, speed, SOC, T)  </li> <li>Peak power requirements  </li> <li>Mission duration  </li> <li>Required reserve energy  </li> <li>Whether mission constraints were satisfied  </li> </ul> <p>These outputs feed directly into:</p> <ul> <li>Powertrain Sizing </li> <li>Battery Sizing </li> <li>WTO iteration </li> <li>Emissions accounting </li> <li>Well\u2011to\u2011Wake energy evaluation</li> </ul>"},{"location":"user-guide/mission/#10-usage-example","title":"10. Usage Example","text":"<pre><code>mission = aircraft.mission\nmission.SetInput()           # load MissionInput dictionary\nmission.InitializeProfile()       # generate profile\nresults = mission.EvaluateMission(WTO) # integrate energy and power use\n</code></pre>"},{"location":"user-guide/mission/#11-limitations","title":"11. Limitations","text":"<ul> <li>Flight mechanics are 1\u2011D (no lateral simulation)  </li> <li>Weather and airport constraints not included  </li> </ul>"}]}